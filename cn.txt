EXP11- SIMULATION OF WIRELESS LAN


set ns [new Simulator]
set val(chan) Channel/WirelessChannel
set val(prop) Propagation/TwoRayGround
set val(netif) Phy/WirelessPhy
set val(ifqtype) Queue/DropTail/PriQueue
set val(ifqlen) 50
set val(mact) Mac/802_11
set val(ll) LL
set val(ant) Antenna/OmniAntenna
set val(rp) AODV
set val(x) 800
set val(y) 800
set val(nn) 13
set tr [open "output.tr" w]
$ns trace-all $tr
set nam_file [open wan_nam.nam w]
$ns namtrace-all-wireless $nam_file $val(x) $val(y)
set topo [new Topography]
$topo load_flatgrid $val(x) $val(y)
create-god $val(nn)
set chan1 [new $val(chan)]
$ns node-config -adhocRouting $val(rp) \
-llType $val(ll) \
-phyType $val(netif) \
-propType $val(prop) \
-ifqType $val(ifqtype) \
-ifqLen $val(ifqlen) \
-antType $val(ant) \
-macType $val(mact) \
-topoInstance $topo \
-agentTrace ON \
-macTrace ON \
-routerTrace ON \
-movementTrace ON \
-channel $chan1
set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]
set n3 [$ns node]
set n4 [$ns node]
set n5 [$ns node]
set n6 [$ns node]
set n7 [$ns node]
set n8 [$ns node]
set n9 [$ns node]
set n10 [$ns node]
set n11 [$ns node]
set n12 [$ns node]
$n0 color "pink"
$ns at 0.0 "$n0 color pink"
$n1 color "pink"
$ns at 0.0 "$n1 color pink"
$n2 color "pink"
$ns at 0.0 "$n2 color pink"
$n3 color "pink"
$ns at 0.0 "$n3 color pink"
$n4 color "pink"
$ns at 0.0 "$n4 color pink"
$n5 color "pink"
$ns at 0.0 "$n5 color pink"
$n6 color "pink"
$ns at 0.0 "$n6 color pink"
$n7 color "blue"
$ns at 0.0 "$n7 color blue"
$n8 color "blue"
$ns at 0.0 "$n8 color blue"
$n9 color "blue"
$ns at 0.0 "$n9 color blue"
$n10 color "blue"
$ns at 0.0 "$n10 color blue"
$n11 color "blue"
$ns at 0.0 "$n11 color blue"
$n12 color "blue"
$ns at 0.0 "$n12 color blue"
$ns duplex-link $n6 $n7 0.3Gb 200ms DropTail
$n0 set X_ 40.0
$n0 set Y_ 200.0
$n0 set Z_ 0.0
$n1 set X_ 80.0
$n1 set Y_ 500.0
$n1 set Z_ 0.0
$n2 set X_ 120.0
$n2 set Y_ 230.0
$n2 set Z_ 0.0
$n3 set X_ 120.0
$n3 set Y_ 280.0
$n3 set Z_ 0.0
$n4 set X_ 280.0
$n4 set Y_ 320.0
$n4 set Z_ 0.0
$n5 set X_ 270.0
$n5 set Y_ 120.0
$n5 set Z_ 0.0
$n6 set X_ 300.0
$n6 set Y_ 400.0
$n6 set Z_ 0.0
$n7 set X_ 500.0
$n7 set Y_ 400.0
$n7 set Z_ 0.0
$n8 set X_ 560.0
$n8 set Y_ 400.0
$n8 set Z_ 0.0
$n9 set X_ 590.0
$n9 set Y_ 320.0
$n9 set Z_ 0.0
$n10 set X_ 570.0
$n10 set Y_ 120.0
$n10 set Z_ 0.0
$n11 set X_ 630.0
$n11 set Y_ 320.0
$n11 set Z_ 0.0
$n12 set X_ 610.0
$n12 set Y_ 120.0
$n12 set Z_ 0.0
#Initial positions..
$n0 random-motion 0
$n1 random-motion 0
$n2 random-motion 0
$n3 random-motion 0
$n4 random-motion 0
$n5 random-motion 0
$n6 random-motion 0
$n7 random-motion 0
$n8 random-motion 0
$n9 random-motion 0
$n10 random-motion 0
$n11 random-motion 0
$n12 random-motion 0
#Inital node positions its size
$ns initial_node_pos $n0 30
$ns initial_node_pos $n1 30
$ns initial_node_pos $n2 30
$ns initial_node_pos $n3 30
$ns initial_node_pos $n4 30
$ns initial_node_pos $n5 30
$ns initial_node_pos $n6 30
$ns initial_node_pos $n7 30
$ns initial_node_pos $n8 30
$ns initial_node_pos $n9 30
$ns initial_node_pos $n10 30
$ns initial_node_pos $n11 30
$ns initial_node_pos $n12 30
set tcps1 [new Agent/TCP]
set tcpr1 [new Agent/TCPSink]
set app1 [new Application/FTP]
$app1 attach-agent $tcps1
$ns attach-agent $n1 $tcps1
$ns attach-agent $n8 $tcpr1
$ns connect $tcps1 $tcpr1
proc finish { } {
global ns tr nam_file
$ns flush-trace
close $tr
close $nam_file
exec nam wan_nam.nam &
exit 0
}
$ns at 0.01 "$app1 start"
$ns at 10 "finish"
$ns run
AWK code:-
BEGIN {
seqno = -1;
receivedPackets = 0;
count = 0;
}
{
#packet delivery ratio
if($4 == "AGT" && $1 == "s" && seqno < $6) {
seqno = $6;
}
else if(($4 == "AGT") && ($1 == "r")) {
receivedPackets++;
}
#end-to-end delay
if($4 == "AGT" && $1 == "s") {
start_time[$6] = $2;
}
else if(($7 == "tcp") && ($1 == "r")) {
end_time[$6] = $2;
}
else if($1 == "D" && $7 == "tcp") {
end_time[$6] = -1;
}
}
END {
for(i=0; i<=seqno; i++) {
if(end_time[i] > 0) {
delay[i] = end_time[i] - start_time[i];
count++;
}
else {
delay[i] = -1;
}
}
for(i=0; i<count; i++) {
if(delay[i] > 0) {
n_to_n_delay = n_to_n_delay + delay[i];
}
}
print "\n";
print "GeneratedPackets = " seqno+1;
print "ReceivedPackets = " receivedPackets;
print "Packet Delivery Ratio = "receivedPackets/(seqno+1)*100"%";
print "Total Dropped Packets = " (seqno+1)-receivedPackets;
if(count>0){
n_to_n_delay = n_to_n_delay/count;
print "Average End-to-End Delay = " n_to_n_delay * 1000 " ms";
print "\n";}
else{
print "No packets"
}
}
------------------------------

EXP10- ETHERNET LAN

EX 10(SIMULATION AND ANALYSIS OF ETHERNET LAN IEEE 802.3):-
TCL code:-
set ns [new Simulator]
set tr [open "LAN.tr" w]
$ns trace-all $tr
set nam [open "LAN.nam" w]
$ns namtrace-all $nam
set n1 [$ns node]
set n2 [$ns node]
set n3 [$ns node]
set n4 [$ns node]
set n5 [$ns node]
set n6 [$ns node]
$ns make-lan "$n1 $n2 $n3 $n4 $n5 $n6" 0.2Mb 20ms LL Queue/DropTail Mac/802_3
set tcpsendagent1 [new Agent/TCP]
set tcpsendagent2 [new Agent/TCP]
set tcprecvagent1 [new Agent/TCPSink]
set tcprecvagent2 [new Agent/TCPSink]
$ns attach-agent $n1 $tcpsendagent1
$ns attach-agent $n2 $tcpsendagent2
$ns attach-agent $n6 $tcprecvagent1
$ns attach-agent $n6 $tcprecvagent2
set app1 [new Application/FTP]
set app2 [new Application/FTP]
$app1 attach-agent $tcpsendagent1
$app2 attach-agent $tcpsendagent2
#As soon as you create agents make sure i connect them
$ns connect $tcpsendagent1 $tcprecvagent1
$ns connect $tcpsendagent2 $tcprecvagent2
$ns at 0.1 "$app1 start"
$ns at 0.4 "$app2 start"
proc finish { } {
global ns tr nam
$ns flush-trace
close $tr
close $nam
exec nam LAN.nam &
exec gawk -f analysis_BW-Delay.awk LAN.tr &
exit 0
}
$ns at 10 "finish"
$ns run
AWK code:-
BEGIN{
drop=0
recv=0
starttime1=0
endtime1=0
latency1=0
filesize1=0
starttime2=0
endtime2=0
latency2=0
filesize2=0
flag0=0
flag1=0
bandwidth1=0
bandwidth2=0
}
{
if($1=="r" && $3==6)
{
if(flag1=0)
{
flag1=1
starttime1=$2
}
filesize1+=$6
endtime1=$2
latency=endtime1-starttime1
bandwidth1=filesize1/latency
printf "%f %f\n", endtime1, bandwidth1 >> "file3.xg"
}
}
END{
print("\n\n\n Final Values..")
print("\n\nfilesize : ",filesize1)
latency=endtime1-starttime1
print("\nlatency :",latency)
bandwidth1=filesize1/latency
print("\n Throughput (Mbps):",bandwidth1/10^6)
}


----------------------------

DHCP

EX 9(SIMULATION OF DHCP(DYNAMIC HOST CONFIGURATION PROTOCOL)):-
SERVER:-
import java.io.*;
import java.net.*;
import java.util.*;
public class DHCPServer {
private static final int SERVER_PORT = 4900;
// private static final String SERVER_IP = "127.0.0.1"; // Change to your server's IP
private static final String IP_ALLOCATIONS_FILE = "ip_allocations.txt";
private static List<String> availableIpAddresses = new ArrayList<>();
private static Map<String, String> ipAllocations = new HashMap<>();
public static void main(String[] args) {
loadIpAllocations(); // Load IP allocations from file (if available)
initializeIpAddresses();
try {
DatagramSocket socket = new DatagramSocket(SERVER_PORT);
while (true) {
byte[] receiveData = new byte[1024];
DatagramPacket receivePacket = new DatagramPacket(receiveData,
receiveData.length);
socket.receive(receivePacket);
// Simulate IP address allocation
InetAddress clientAddress = receivePacket.getAddress();
String macAddress = extractMacAddress(receiveData);
String allocatedIp = allocateIpAddress(macAddress);
// Create and send DHCP response
byte[] responseData = createDHCPResponse(macAddress, allocatedIp);
DatagramPacket responsePacket = new DatagramPacket(responseData,
responseData.length,
clientAddress, receivePacket.getPort());
socket.send(responsePacket);
System.out.println("Allocated IP " + allocatedIp + " to client with MAC " +
macAddress);
// Save IP allocations to file
saveIpAllocations();
}
} catch (Exception e) {
e.printStackTrace();
}
}
private static void initializeIpAddresses() {
// Simulate a pool of available IP addresses
for (int i = 2; i <= 254; i++) {
availableIpAddresses.add("192.168.1." + i);
}
}
private static String extractMacAddress(byte[] data) {
// Simulate extracting MAC address from DHCP request
// In a real implementation, you'd parse the DHCP request to get the MAC address
return "00:11:22:33:44:55"; // Placeholder
}
private static String allocateIpAddress(String macAddress) {
if (availableIpAddresses.isEmpty()) {
return "No available IP addresses";
}
Random random = new Random();
int index = random.nextInt(availableIpAddresses.size());
String allocatedIp = availableIpAddresses.remove(index);
// Bind MAC address with the allocated IP address
ipAllocations.put(macAddress, allocatedIp);
return allocatedIp;
}
private static byte[] createDHCPResponse(String macAddress, String allocatedIp) {
// Simulate creating a DHCP response with the allocated IP address
// In a real implementation, you'd construct a proper DHCP packet
return ("Allocated IP: " + allocatedIp).getBytes();
}
private static void saveIpAllocations() {
try (ObjectOutputStream outputStream = new ObjectOutputStream(new
FileOutputStream(IP_ALLOCATIONS_FILE))) {
outputStream.writeObject(ipAllocations);
System.out.println("Saved IP allocations to " + IP_ALLOCATIONS_FILE);
} catch (IOException e) {
e.printStackTrace();
}
}
private static void loadIpAllocations() {
try (ObjectInputStream inputStream = new ObjectInputStream(new
FileInputStream(IP_ALLOCATIONS_FILE))) {
ipAllocations = (HashMap<String, String>) inputStream.readObject();
System.out.println("Loaded IP allocations from " + IP_ALLOCATIONS_FILE);
} catch (FileNotFoundException e) {
System.out.println(IP_ALLOCATIONS_FILE + " not found. Starting with an empty IP
allocations map.");
} catch (IOException | ClassNotFoundException e) {
e.printStackTrace();
}
}
}
CLIENT:-
import java.net.*;
import java.util.Arrays;
public class DHCPClient {
private static final int SERVER_PORT = 4900;
private static final String SERVER_IP = "127.0.0.1"; // Change to your server's IP
public static void main(String[] args) {
try {
DatagramSocket socket = new DatagramSocket();
InetAddress serverAddress = InetAddress.getByName(SERVER_IP);
// Create and send DHCP request
byte[] requestData = createDHCPRequest("7c:70:db:e1:de:c6"); // Replace with your
MAC address
DatagramPacket requestPacket = new DatagramPacket(requestData,
requestData.length, serverAddress, SERVER_PORT);
socket.send(requestPacket);
// Receive DHCP response
byte[] receiveData = new byte[1024];
DatagramPacket receivePacket = new DatagramPacket(receiveData,
receiveData.length);
socket.receive(receivePacket);
// Process and print DHCP response
String response = new String(receivePacket.getData()).trim();
System.out.println("Received DHCP Response: " + response);
} catch (Exception e) {
e.printStackTrace();
}
}
private static byte[] createDHCPRequest(String macAddress) {
// Simulate creating a DHCP request packet with the MAC address
// In a real implementation, you'd construct a proper DHCP packet
String request = "DHCP Request with MAC: " + macAddress;
return request.getBytes();
}
}

-----------------------------------------------------------------------------------------
EX 8(SIMULATION AND ANALYSIS OF MULTICAST ROUTING):-
TCL code:-
set ns [new Simulator -multicast on]
#Turn on Tracing
set tf [open output.tr w]
$ns trace-all $tf
# Turn on nam Tracing
set fd [open mcast.nam w]
$ns namtrace-all $fd
# Create nodes
set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]
set n3 [$ns node]
set n4 [$ns node]
set n5 [$ns node]
set n6 [$ns node]
set n7 [$ns node]
# Create links with DropTail Queues
$ns duplex-link $n0 $n2 1.5Mb 10ms DropTail
$ns duplex-link $n1 $n2 1.5Mb 10ms DropTail
$ns duplex-link $n2 $n3 1.5Mb 10ms DropTail
$ns duplex-link $n3 $n4 1.5Mb 10ms DropTail
$ns duplex-link $n3 $n7 1.5Mb 10ms DropTail
$ns duplex-link $n4 $n5 1.5Mb 10ms DropTail
$ns duplex-link $n4 $n6 1.5Mb 10ms DropTail
#DM: dense-mode; SM: sparse-mode
set mproto DM
set mrthandle [$ns mrtproto $mproto {}]
# Set two groups with group addresses
set group1 [Node allocaddr]
set group2 [Node allocaddr]
# UDP Transport agent for the traffic source for group1
set udp0 [new Agent/UDP]
$ns attach-agent $n0 $udp0
$udp0 set dst_addr_ $group1
$udp0 set dst_port_ 0
set cbr1 [new Application/Traffic/CBR]
$cbr1 attach-agent $udp0
# Transport agent for the traffic source for group2
set udp1 [new Agent/UDP]
$ns attach-agent $n1 $udp1
$udp1 set dst_addr_ $group2
$udp1 set dst_port_ 0
set cbr2 [new Application/Traffic/CBR]
$cbr2 attach-agent $udp1
# Create receiver to accept the packets
set rcvr1 [new Agent/Null]
$ns attach-agent $n5 $rcvr1
$ns at 1.0 "$n5 join-group $rcvr1 $group1"
set rcvr2 [new Agent/Null]
$ns attach-agent $n6 $rcvr2
$ns at 1.5 "$n6 join-group $rcvr2 $group1"
set rcvr3 [new Agent/Null]
$ns attach-agent $n7 $rcvr3
$ns at 2.0 "$n7 join-group $rcvr3 $group1"
set rcvr4 [new Agent/Null]
$ns attach-agent $n5 $rcvr1
$ns at 2.5 "$n5 join-group $rcvr4 $group2"
set rcvr5 [new Agent/Null]
$ns attach-agent $n6 $rcvr2
$ns at 3.0 "$n6 join-group $rcvr5 $group2"
set rcvr6 [new Agent/Null]
$ns attach-agent $n7 $rcvr3
#The nodes are leaving the group at specified times
$ns at 3.5 "$n7 join-group $rcvr6 $group2"
$ns at 4.0 "$n5 leave-group $rcvr1 $group1"
$ns at 4.5 "$n6 leave-group $rcvr2 $group1"
$ns at 5.0 "$n7 leave-group $rcvr3 $group1"
$ns at 5.5 "$n5 leave-group $rcvr4 $group2"
$ns at 6.0 "$n6 leave-group $rcvr5 $group2"
$ns at 6.5 "$n7 leave-group $rcvr6 $group2"
# Schedule events
$ns at 0.5 "$cbr1 start"
$ns at 9.5 "$cbr1 stop"
$ns at 0.5 "$cbr2 start"
$ns at 9.5 "$cbr2 stop"
#post-processing
$ns at 10.0 "finish"
proc finish {} {
global ns tf
$ns flush-trace
close $tf
exec nam mcast.nam &
exit 0
}
$ns set-animation-rate 3.0ms
$ns run
AWK code:-
BEGIN {
rec= 0
drp=0
tot=0
rat=0.0
sum=0
sum1=0
throughput=0.0
throughput1=0.0
}
{ if($1== "r" && $4== 4)
{ rec++
}
if($1== "d" && $4 ==4 )
{ drp++
}
if($2>1.00 && $4==4)
{sum=sum+$6
}
if($2>1.00 && $4==5)
{ sum1=sum1+$6
}
}
END {
tot = rec + drp
rat = (rec/tot) *100
throughput= (sum*8)/1000000
throughput1=(sum1*8)/1000000
printf(" \n Packets received %d ", rec)
printf(" \n Packets dropped %d ", drp)
printf("\n Packets delivery ratio %f",rat)
printf("\n Throughput for udp is %f",throughput)
printf("\n Throughput for tcp is %f",throughput1)
}
--------------------------------------------------------------------------------------------

TCP CONGESTION CONTROL:-
TCL code:-
VARIANT 1(SINGLE CC MODE, SINGLE FILE OBJECT FOR THROUGHPUT AND
BANDWIDTH):-
#creating a simulator object
set ns [ new Simulator ]
$ns color 3 Green
#creating trace file
set tf [open vegas.tr w]
$ns trace-all $tf
#creating nam file
set nf [open vegas.nam w]
$ns namtrace-all $nf
#creating variables for throughput files
set ft1 [open "vegas_Sender_throughput" "w"]
#creating variables for bandwidth files
set fb1 [open "vegas_Sender_bandwidth" "w"]
#finish procedure to call nam and xgraph
proc finish {} {
global ns nf ft1 fb1
$ns flush-trace
#closing all files
close $nf
close $ft1
close $fb1
#executing graphs
exec xgraph vegas_Sender_throughput -geometry 500x500 &
exec xgraph vegas_Sender_bandwidth -geometry 500x500 &
puts "running nam..."
exec nam vegas.nam &
#exec awk -f cc-analysis.awk trace1.tr &
exit 0
}
#record procedure to calculate total bandwidth and throughput
proc record {} {
global null1 ft1 fb1
global http1
set ns [Simulator instance]
set time 0.1
set now [$ns now]
set bw1 [$null1 set bytes_]
puts $ft1 "$now [expr $bw1/$time*8/1000000]"
puts $fb1 "$now [expr $bw1]"
$null1 set bytes_ 0
$ns at [expr $now+$time] "record"
}
#creating 10 nodes
for {set i 0} {$i < 6} {incr i} {
set n($i) [$ns node]
}
#creating duplex links
$ns duplex-link $n(0) $n(1) 10Kb 10ms DropTail
$ns duplex-link $n(0) $n(3) 100Kb 10ms RED
$ns duplex-link $n(1) $n(2) 50Kb 10ms DropTail
$ns duplex-link $n(2) $n(5) 200Kb 10ms RED
$ns duplex-link $n(3) $n(4) 70Kb 10ms DropTail
$ns duplex-link $n(4) $n(5) 100Kb 10ms DropTail
#orienting links
$ns duplex-link-op $n(0) $n(1) orient right
$ns duplex-link-op $n(1) $n(2) orient right-down
$ns duplex-link-op $n(0) $n(3) orient left-down
$ns duplex-link-op $n(3) $n(4) orient right-down
$ns duplex-link-op $n(4) $n(5) orient right
$ns duplex-link-op $n(2) $n(5) orient left-down
set tcp1 [new Agent/TCP/Vegas]
#other possible options - Reno-[new Agent/TCP/Reno] or
#Newreno-[new Agent/TCP/Newreno] or SACK-[new Agent/TCP/Sack1] or
#Tahoe-[new Agent/TCP]
set null1 [new Agent/TCPSink]
$ns attach-agent $n(0) $tcp1
$ns attach-agent $n(5) $null1
$ns connect $tcp1 $null1
set http1 [new Application/Traffic/Exponential]
$http1 attach-agent $tcp1
#scheduling events
$ns at 0.5 "record"
$ns at 0.2 "$ns trace-annotate \"Starting HTTP from 0 to 10\""
$ns at 0.2 "$n(0) color \"green\""
$ns at 0.2 "$n(5) color \"green\""
$ns at 0.2 "$http1 start"
$ns at 3.2 "$http1 stop"
$ns at 5.0 "finish"
$ns run
VARIANT 2(SINGLE CC MODE, MULTIPLE FILE OBJECTS FOR THROUGHPUT AND
BANDWIDTH):-
#creating a simulator object
set ns [ new Simulator ]
$ns color 3 Green
#creating trace file
set tf [open vegas.tr w]
$ns trace-all $tf
#creating nam file
set nf [open vegas.nam w]
$ns namtrace-all $nf
#creating variables for throughput files
set ft1 [open "vegas_Sender_throughput" "w"]
# extra variables for extra throughput files
set ft2 [open "vegas_Sender_throughput2" "w"]
set ft3 [open "vegas_Sender_throughput3" "w"]
set ftt [open "vegas_Sender_Total_throughput" "w"]
# extra variables for extra throughput files(end)
#creating variables for bandwidth files
set fb1 [open "vegas_Sender_bandwidth" "w"]
#extra variables for extra bandwidth files
set fb2 [open "vegas_Sender_bandwidth2" "w"]
set fb3 [open "vegas_Sender_bandwidth3" "w"]
set fbt [open "vegas_Sender_Total_bandwidth" "w"]
#extra variables for extra bandwidth files(end)
#finish procedure to call nam and xgraph
proc finish {} {
global ns nf ft1 ft2 ft3 ftt fb1 fb2 fb3 fbt
$ns flush-trace
#closing all files
close $nf
close $ft1
close $ft2
close $ft3
close $ftt
close $fb1
close $fb2
close $fb3
close $fbt
#executing graphs
exec xgraph vegas_Sender_throughput vegas_Sender_throughput2
vegas_Sender_throughput3 &
exec xgraph vegas_Sender_bandwidth vegas_Sender_bandwidth2 vegas_Sender_bandwidth3
&
puts "running nam..."
exec nam vegas.nam &
#exec awk -f cc-analysis.awk trace1.tr &
exit 0
}
#record procedure to calculate total bandwidth and throughput
proc record {} {
global null1 null2 null3 ft1 ft2 ft3 ftt fb1 fb2 fb3 fbt
global http1 http2 http3
set ns [Simulator instance]
set time 0.1
set now [$ns now]
set bw1 [$null1 set bytes_]
set bw2 [$null2 set bytes_]
set bw3 [$null3 set bytes_]
set totalbd [expr $bw1 + $bw2 + $bw3]
puts $ft1 "$now [expr $bw1/$time*8/1000000]"
puts $fb1 "$now [expr $bw1]"
puts $ft2 "$now [expr $bw2/$time*8/1000000]"
puts $fb2 "$now [expr $bw2]"
puts $ft3 "$now [expr $bw3/$time*8/1000000]"
puts $fb3 "$now [expr $bw3]"
puts $ftt "$now [expr $totalbd/$time*8/1000000]"
puts $fbt "$now [expr $totalbd]"
$null1 set bytes_ 0
$null2 set bytes_ 0
$null3 set bytes_ 0
$ns at [expr $now+$time] "record"
}
#creating 10 nodes
for {set i 0} {$i < 6} {incr i} {
set n($i) [$ns node]
}
#creating duplex links
$ns duplex-link $n(0) $n(1) 10Kb 10ms DropTail
$ns duplex-link $n(0) $n(3) 100Kb 10ms RED
$ns duplex-link $n(1) $n(2) 50Kb 10ms DropTail
$ns duplex-link $n(2) $n(5) 200Kb 10ms RED
$ns duplex-link $n(3) $n(4) 70Kb 10ms DropTail
$ns duplex-link $n(4) $n(5) 100Kb 10ms DropTail
#orienting links
$ns duplex-link-op $n(0) $n(1) orient right
$ns duplex-link-op $n(1) $n(2) orient right-down
$ns duplex-link-op $n(0) $n(3) orient left-down
$ns duplex-link-op $n(3) $n(4) orient right-down
$ns duplex-link-op $n(4) $n(5) orient right
$ns duplex-link-op $n(2) $n(5) orient left-down
set tcp1 [new Agent/TCP/Vegas]
#other possible options - Reno-[new Agent/TCP/Reno] or
#Newreno-[new Agent/TCP/Newreno] or SACK-[new Agent/TCP/Sack1] or
#Tahoe-[new Agent/TCP]
set null1 [new Agent/TCPSink]
$ns attach-agent $n(0) $tcp1
$ns attach-agent $n(5) $null1
$ns connect $tcp1 $null1
set http1 [new Application/Traffic/Exponential]
$http1 attach-agent $tcp1
#additional agents
set tcp2 [new Agent/TCP/Vegas]
set null2 [new Agent/TCPSink]
$ns attach-agent $n(1) $tcp2
$ns attach-agent $n(5) $null2
$ns connect $tcp2 $null2
set http2 [new Application/Traffic/Exponential]
$http2 attach-agent $tcp2
set tcp3 [new Agent/TCP/Vegas]
set null3 [new Agent/TCPSink]
$ns attach-agent $n(2) $tcp3
$ns attach-agent $n(5) $null3
$ns connect $tcp3 $null3
set http3 [new Application/Traffic/Exponential]
$http3 attach-agent $tcp3
#additional agents(end)
#scheduling events
$ns at 0.5 "record"
$ns at 0.2 "$ns trace-annotate \"Starting HTTP from 0 to 10\""
$ns at 0.2 "$n(0) color \"green\""
$ns at 0.2 "$n(5) color \"green\""
$ns at 0.2 "$http1 start"
$ns at 3.2 "$http1 stop"
# extra node scheduling
$ns at 3.2 "$n(1) color \"red\""
$ns at 3.2 "$n(5) color \"red\""
$ns at 3.2 "$http2 start"
$ns at 6.2 "$http2 stop"
$ns at 6.2 "$n(2) color \"yellow\""
$ns at 6.2 "$n(5) color \"yellow\""
$ns at 6.2 "$http3 start"
$ns at 9.2 "$http3 stop"
# extra node scheduling(end)
$ns at 10.0 "finish"
$ns run
VARIANT 3(ALL CC MODES[VEGAS+TAHOE+RENO+NEWRENO+SACK]):-
#creating a simulator object
set ns [ new Simulator ]
$ns color 3 Green
#creating trace file
set tf [open TCPcc.tr w]
$ns trace-all $tf
#creating nam file
set nf [open TCPcc.nam w]
$ns namtrace-all $nf
#creating throughput files
set ft1 [open vegas_Sender_throughput w]
set ft2 [open Reno_Sender_throughput w]
set ft3 [open Newreno_Sender_throughput w]
set ft4 [open Sack1_Sender_throughput w]
set ft5 [open Tahoe_Sender_throughput w]
#creating bandwidth files
set fb1 [open vegas_Sender_bandwidth w]
set fb2 [open Reno_Sender_bandwidth w]
set fb3 [open Newreno_Sender_bandwidth w]
set fb4 [open Sack1_Sender_bandwidth w]
set fb5 [open Tahoe_Sender_bandwidth w]
#finish procedure to call nam and xgraph
proc finish {} {
global ns nf ft1 ft2 ft3 ft4 ft5 fb1 fb2 fb3 fb4 fb5
$ns flush-trace
#closing all files
close $nf
close $ft1
close $ft2
close $ft3
close $ft4
close $ft5
close $fb1
close $fb2
close $fb3
close $fb4
close $fb5
#executing graphs
exec xgraph vegas_Sender_throughput Reno_Sender_throughput
Newreno_Sender_throughput Sack1_Sender_throughput Tahoe_Sender_throughput &
exec xgraph vegas_Sender_bandwidth Reno_Sender_bandwidth Newreno_Sender_bandwidth
Sack1_Sender_bandwidth Tahoe_Sender_bandwidth &
puts "running nam..."
exec nam TCPcc.nam &
#exec awk -f analysis.awk trace1.tr &
exit 0
}
#record procedure to calculate total bandwidth and throughput
proc record {} {
global null1 null2 null3 null4 null5 ft1 ft2 ft3 ft4 ft5 fb1 fb2 fb3 fb4 fb5
global http1 http2 http3 http4 http5
set ns [Simulator instance]
set time 0.1
set now [$ns now]
set bw1 [$null1 set bytes_]
set bw2 [$null2 set bytes_]
set bw3 [$null3 set bytes_]
set bw4 [$null4 set bytes_]
set bw5 [$null5 set bytes_]
puts $ft1 "$now [expr $bw1/$time*8/1000000]"
puts $ft2 "$now [expr $bw2/$time*8/1000000]"
puts $ft3 "$now [expr $bw3/$time*8/1000000]"
puts $ft4 "$now [expr $bw4/$time*8/1000000]"
puts $ft5 "$now [expr $bw5/$time*8/1000000]"
puts $fb1 "$now [expr $bw1]"
puts $fb2 "$now [expr $bw2]"
puts $fb3 "$now [expr $bw3]"
puts $fb4 "$now [expr $bw4]"
puts $fb5 "$now [expr $bw5]"
$null1 set bytes_ 0
$null2 set bytes_ 0
$null3 set bytes_ 0
$null4 set bytes_ 0
$null5 set bytes_ 0
$ns at [expr $now+$time] "record"
}
#creating 10 nodes
for {set i 0} {$i < 6} {incr i} {
set n($i) [$ns node]
}
#creating duplex links
$ns duplex-link $n(0) $n(1) 10Kb 10ms DropTail
$ns duplex-link $n(0) $n(3) 100Kb 10ms RED
$ns duplex-link $n(1) $n(2) 50Kb 10ms DropTail
$ns duplex-link $n(2) $n(5) 200Kb 10ms RED
$ns duplex-link $n(3) $n(4) 70Kb 10ms DropTail
$ns duplex-link $n(4) $n(5) 100Kb 10ms DropTail
#orienting links
$ns duplex-link-op $n(0) $n(1) orient right
$ns duplex-link-op $n(1) $n(2) orient right-down
$ns duplex-link-op $n(0) $n(3) orient left-down
$ns duplex-link-op $n(3) $n(4) orient right-down
$ns duplex-link-op $n(4) $n(5) orient right
$ns duplex-link-op $n(2) $n(5) orient left-down
set tcp1 [new Agent/TCP/Vegas]
set null1 [new Agent/TCPSink]
$ns attach-agent $n(0) $tcp1
$ns attach-agent $n(5) $null1
$ns connect $tcp1 $null1
set http1 [new Application/Traffic/Exponential]
$http1 attach-agent $tcp1
set tcp2 [new Agent/TCP/Reno]
set null2 [new Agent/TCPSink]
$ns attach-agent $n(1) $tcp2
$ns attach-agent $n(5) $null2
$ns connect $tcp2 $null2
set http2 [new Application/Traffic/Exponential]
$http2 attach-agent $tcp2
set tcp3 [new Agent/TCP/Newreno]
set null3 [new Agent/TCPSink]
$ns attach-agent $n(2) $tcp3
$ns attach-agent $n(5) $null3
$ns connect $tcp3 $null3
set http3 [new Application/Traffic/Exponential]
$http3 attach-agent $tcp3
set tcp4 [new Agent/TCP/Sack1]
set null4 [new Agent/TCPSink]
$ns attach-agent $n(3) $tcp4
$ns attach-agent $n(4) $null4
$ns connect $tcp4 $null4
set http4 [new Application/Traffic/Exponential]
$http4 attach-agent $tcp4
set tcp5 [new Agent/TCP]
set null5 [new Agent/TCPSink]
$ns attach-agent $n(3) $tcp5
$ns attach-agent $n(5) $null5
$ns connect $tcp5 $null5
set http5 [new Application/Traffic/Exponential]
$http5 attach-agent $tcp5
#scheduling events
$ns at 0.5 "record"
$ns at 0.2 "$ns trace-annotate \"Starting HTTP from 0 to 5\""
$ns at 0.2 "$n(0) color \"green\""
$ns at 0.2 "$n(5) color \"green\""
$ns at 0.2 "$http1 start"
$ns at 3.2 "$http1 stop"
$ns at 3.2 "$n(1) color \"green\""
$ns at 3.2 "$n(5) color \"green\""
$ns at 3.2 "$http2 start"
$ns at 6.2 "$http2 stop"
$ns at 6.2 "$n(2) color \"green\""
$ns at 6.2 "$n(5) color \"green\""
$ns at 6.2 "$http3 start"
$ns at 9.2 "$http3 stop"
$ns at 9.2 "$n(3) color \"green\""
$ns at 9.2 "$n(4) color \"green\""
$ns at 9.2 "$http4 start"
$ns at 12.2 "$http4 stop"
$ns at 12.2 "$n(3) color \"green\""
$ns at 12.2 "$n(5) color \"green\""
$ns at 12.2 "$http5 start"
$ns at 15.2 "$http5 stop"
$ns at 16.0 "finish"
$ns run
AWK code:-
BEGIN{
st1=0
ft1=0
throughput1=0
delay1=0
flag1=0
data1=0
}
{
if($1=="r"&&$4==5)#http
{
data1+=$6
if(flag1==0)
{
st1=$2
flag1=1
}
if(flag1==1)
{
ft1=$2
}
}
}
END{
printf("**********HTTP***********\n")
printf("Start time %f\n",st1)
printf("End time %f\n",ft1)
printf("Data %f\n",data1)
delay1=ft1-st1
throughput1=data1/delay1
printf("Throughput %f\n",throughput1)
printf("Delay %f\n",delay1)
}
-----------------------------------------------------------------------------------------------------------
EX 6(SIMULATION AND ANALYSIS OF TCP FLOW CONTROL AND CONGESTION
CONTROL):-
TCP FLOW CONTROL:-
TCL code:-
VARIANT 1(SINGLE FILE OBJECT FOR THROUGHPUT AND BANDWIDTH):-
#creating a simulator object
set ns [ new Simulator ]
#creating trace file
set tf [open trace1.tr w]
$ns trace-all $tf
#creating nam file
set nf [open opnam.nam w]
$ns namtrace-all $nf
#creating variables for throughput files
set ft1 [open "Sender_throughput" "w"]
#creating variables for bandwidth files
set fb1 [open "Bandwidth" "w"]
#finish procedure to call nam and xgraph
proc finish {} {
global ns nf ft1 fb1
$ns flush-trace
#closing all files
close $nf
close $ft1
close $fb1
#executing graphs
exec xgraph Sender_throughput -geometry 500x500 &
exec xgraph Bandwidth -geometry 500x500 &
#for xgraph command, if you are going to give only one parameter(file object name) then
#it won’t work.To rectify it, add the option ‘-geometry n1xn2’( to set dimensions of graph
#file to ‘n1’(length)x’n2’(breadth) )[For 2 and more parameters, this rectification is not
#needed]
puts "running nam..."
exec nam opnam.nam &
#exec awk -f analysis.awk trace1.tr
exit 0
}
#record procedure to calculate total bandwidth and throughput
proc record {} {
global null1 ft1 fb1
global ftp1
set ns [Simulator instance]
set time 0.1
set now [$ns now]
set bw0 [$null1 set bytes_]
puts $ft1 "$now [expr $bw0/$time*8/1000000]"
puts $fb1 "$now [expr $bw0]"
$null1 set bytes_ 0
$ns at [expr $now+$time] "record"
}
#creating 10 nodes
for {set i 0} {$i < 10} {incr i} {
set n($i) [$ns node]
}
#creating duplex links
$ns duplex-link $n(0) $n(1) 1Mb 10ms DropTail
$ns duplex-link $n(0) $n(3) 1.5Mb 10ms RED
$ns duplex-link $n(1) $n(2) 1Mb 10ms DropTail
$ns duplex-link $n(2) $n(7) 2Mb 10ms RED
$ns duplex-link $n(7) $n(8) 2Mb 10ms DropTail
$ns duplex-link $n(8) $n(9) 2Kb 10ms RED
$ns duplex-link $n(3) $n(5) 1Kb 10ms DropTail
$ns duplex-link $n(5) $n(6) 1Kb 10ms RED
$ns duplex-link $n(6) $n(4) 1Kb 10ms DropTail
$ns duplex-link $n(4) $n(7) 1Kb 10ms RED
#orienting links
$ns duplex-link-op $n(0) $n(1) orient right-up
$ns duplex-link-op $n(1) $n(2) orient right
$ns duplex-link-op $n(0) $n(3) orient right-down
$ns duplex-link-op $n(2) $n(7) orient right-down
$ns duplex-link-op $n(7) $n(8) orient right-up
$ns duplex-link-op $n(5) $n(6) orient right
$ns duplex-link-op $n(6) $n(4) orient left-up
$ns duplex-link-op $n(3) $n(5) orient right-down
$ns duplex-link-op $n(4) $n(7) orient right-up
$ns duplex-link-op $n(8) $n(9) orient right-down
proc ftp_traffic {node0 node9 } {
global ns null1 tcp1 ftp1
set tcp1 [new Agent/TCP]
set null1 [new Agent/TCPSink]
$ns attach-agent $node0 $tcp1
$ns attach-agent $node9 $null1
$ns connect $tcp1 $null1
set ftp1 [new Application/FTP]
#in this example, single file object is FTP. For implementing HTTP/SMTP,
#use [new Application/Traffic/Exponential] instead of [new Application/FTP]
$ftp1 attach-agent $tcp1
$ns at 1.0 "$ftp1 start"
$ns at 3.2 "$ftp1 stop"
}
ftp_traffic $n(0) $n(8)
#scheduling events
$ns at 0.5 "record"
$ns at 1.0 "$ns trace-annotate \"Starting FTP from 0 to 8\""
$ns at 5.0 "finish"
$ns run
VARIANT 2(MULTIPLE FILE OBJECTS FOR THROUGHPUT AND BANDWIDTH):-
#creating a simulator object
set ns [ new Simulator ]
#creating trace file
set tf [open trace1.tr w]
$ns trace-all $tf
#creating nam file
set nf [open opnam.nam w]
$ns namtrace-all $nf
#creating variables for throughput files
set ft1 [open "Sender1_throughput" "w"]
set ft2 [open "Sender2_throughput" "w"]
set ft3 [open "Sender3_throughput" "w"]
set ft4 [open "Total_throughput" "w"]
#creating variables for bandwidth files
set fb1 [open "Bandwidth1" "w"]
set fb2 [open "Bandwidth2" "w"]
set fb3 [open "Bandwidth3" "w"]
set fb4 [open "TotalBandwidth" "w"]
#finish procedure to call nam and xgraph
proc finish {} {
global ns nf ft1 ft2 ft3 ft4 fb1 fb2 fb3 fb4
$ns flush-trace
#closing all files
close $nf
close $ft1
close $ft2
close $ft3
close $ft4
close $fb1
close $fb2
close $fb3
close $fb4
#executing graphs
exec xgraph Sender1_throughput Sender2_throughput Sender3_throughput Total_throughput
&
exec xgraph Bandwidth1 Bandwidth2 Bandwidth3 TotalBandwidth &
puts "running nam..."
exec nam opnam.nam &
#exec awk -f analysis.awk trace1.tr
exit 0
}
#record procedure to calculate total bandwidth and throughput
proc record {} {
global null1 null2 null3 ft1 ft2 ft3 ft4 fb1 fb2 fb3 fb4
global ftp1 smtp1 http1
set ns [Simulator instance]
set time 0.1
set now [$ns now]
set bw0 [$null1 set bytes_]
set bw1 [$null2 set bytes_]
set bw2 [$null3 set bytes_]
set totbw [expr $bw0 + $bw1 + $bw2]
puts $ft4 "$now [expr $totbw/$time*8/1000000]"
puts $ft1 "$now [expr $bw0/$time*8/1000000]"
puts $ft2 "$now [expr $bw1/$time*8/1000000]"
puts $ft3 "$now [expr $bw2/$time*8/1000000]"
puts $fb1 "$now [expr $bw0]"
puts $fb2 "$now [expr $bw1]"
puts $fb3 "$now [expr $bw2]"
puts $fb4 "$now [expr $totbw]"
$null1 set bytes_ 0
$null2 set bytes_ 0
$null3 set bytes_ 0
$ns at [expr $now+$time] "record"
}
#creating 10 nodes
for {set i 0} {$i < 10} {incr i} {
set n($i) [$ns node]
}
#creating duplex links
$ns duplex-link $n(0) $n(1) 1Mb 10ms DropTail
$ns duplex-link $n(0) $n(3) 1.5Mb 10ms RED
$ns duplex-link $n(1) $n(2) 1Mb 10ms DropTail
$ns duplex-link $n(2) $n(7) 2Mb 10ms RED
$ns duplex-link $n(7) $n(8) 2Mb 10ms DropTail
$ns duplex-link $n(8) $n(9) 2Kb 10ms RED
$ns duplex-link $n(3) $n(5) 1Kb 10ms DropTail
$ns duplex-link $n(5) $n(6) 1Kb 10ms RED
$ns duplex-link $n(6) $n(4) 1Kb 10ms DropTail
$ns duplex-link $n(4) $n(7) 1Kb 10ms RED
#orienting links
$ns duplex-link-op $n(0) $n(1) orient right-up
$ns duplex-link-op $n(1) $n(2) orient right
$ns duplex-link-op $n(0) $n(3) orient right-down
$ns duplex-link-op $n(2) $n(7) orient right-down
$ns duplex-link-op $n(7) $n(8) orient right-up
$ns duplex-link-op $n(5) $n(6) orient right
$ns duplex-link-op $n(6) $n(4) orient left-up
$ns duplex-link-op $n(3) $n(5) orient right-down
$ns duplex-link-op $n(4) $n(7) orient right-up
$ns duplex-link-op $n(8) $n(9) orient right-down
proc ftp_traffic {node0 node9 } {
global ns null1 tcp1 ftp1
set tcp1 [new Agent/TCP]
set null1 [new Agent/TCPSink]
$ns attach-agent $node0 $tcp1
$ns attach-agent $node9 $null1
$ns connect $tcp1 $null1
set ftp1 [new Application/FTP]
$ftp1 attach-agent $tcp1
$ns at 1.0 "$ftp1 start"
$ns at 3.2 "$ftp1 stop"
}
ftp_traffic $n(0) $n(8)
proc smtp_traffic {node0 node3 } {
global ns null2 tcp2 smtp1
set tcp2 [new Agent/TCP]
set null2 [new Agent/TCPSink]
$ns attach-agent $node0 $tcp2
$ns attach-agent $node3 $null2
$ns connect $tcp2 $null2
set smtp1 [new Application/Traffic/Exponential]
$smtp1 attach-agent $tcp2
$ns at 2.0 "$smtp1 start"
$ns at 3.8 "$smtp1 stop"
}
smtp_traffic $n(3) $n(6)
proc http_traffic {node1 node7 } {
global ns null3 tcp3 http1
set tcp3 [new Agent/TCP]
set null3 [new Agent/TCPSink]
$ns attach-agent $node1 $tcp3
$ns attach-agent $node7 $null3
$ns connect $tcp3 $null3
set http1 [new Application/Traffic/Exponential]
$http1 attach-agent $tcp3
$ns at 0.2 "$http1 start"
$ns at 3.2 "$http1 stop" }
http_traffic $n(0) $n(7)
#scheduling events
$ns at 0.5 "record"
$ns at 0.2 "$ns trace-annotate \"Starting HTTP from 0 to 7\""
$ns at 1.0 "$ns trace-annotate \"Starting FTP from 0 to 8\""
$ns at 2.0 "$ns trace-annotate \"Starting SMTP from 3 to 6\""
$ns at 5.0 "finish"
$ns run
AWK code:-
VARIANT 1(SINGLE FILE OBJECT FOR THROUGHPUT AND BANDWIDTH):-
BEGIN{
st2=0
ft2=0
throughput2=0
delay2=0
flag2=0
data2=0
}
{
if($1=="r"&&$4==8) #ftp(for http, $4==7 and for smtp, $4==6)
{
data2+=$6
if(flag2==0)
{
st2=$2
flag2=1
}
if(flag2==1)
{
ft2=$2
}
}
}
END{
printf("**********FTP***********\n")
printf("start time %f\n",st2)
printf("end time %f\n",ft2)
printf("data %f\n",data2)
delay2=ft2-st2
throughput2=data2/delay2
printf("throughput %f\n",throughput2)
printf("delay %f\n",delay2)
}
VARIANT 2(MULTIPLE FILE OBJECTS FOR THROUGHPUT AND BANDWIDTH):-
BEGIN{
st1=0
ft1=0
throughput1=0
delay1=0
flag1=0
data1=0
st2=0
ft2=0
throughput2=0
delay2=0
flag2=0
data2=0
st3=0
ft3=0
throughput3=0
delay3=0
flag3=0
data3=0
total_delay=0
total_th=0
}
{
if($1=="r"&&$4==7)#http
{
data1+=$6
if(flag1==0)
{
st1=$2
flag1=1
}
if(flag1==1)
{
ft1=$2
}
}
if($1=="r"&&$4==8)#ftp
{
data2+=$6
if(flag2==0)
{
st2=$2
flag2=1
}
if(flag2==1)
{
ft2=$2
}
}
if($1=="r"&&$4==6)#smtp
{
data3+=$6
if(flag3==0)
{
st3=$2
flag3=1
}
if(flag3==1)
{
ft3=$2
}
}
}
END{
printf("**********HTTP***********\n")
printf("start time %f\n",st1)
printf("end time %f\n",ft1)
printf("data %f\n",data1)
delay1=ft1-st1
throughput1=data1/delay1
printf("throughput %f\n",throughput1)
printf("delay %f\n",delay1)
printf("**********SMTP***********\n")
printf("start time %f\n",st3)
printf("end time %f\n",ft3)
printf("data %f\n",data3)
delay3=ft3-st3
throughput3=data3/delay3
printf("throughput %f\n",throughput3)
printf("delay %f\n",delay3)
printf("**********FTP***********\n")
printf("start time %f\n",st2)
printf("end time %f\n",ft2)
printf("data %f\n",data2)
delay2=ft2-st2
throughput2=data2/delay2
printf("throughput %f\n",throughput2)
printf("delay %f\n",delay2)
total_th=throughput1+throughput2+throughput3
total_delay=delay1+delay2+delay3
printf("Avg throughput %f\n",total_th/3)
printf("Avg delay%f\n",total_delay/3)
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
EX 5 (WIRELESS SIMULATION):-
TCL FILE
#Example of Wireless networks
#Step 1 initialize variables
#Step 2 - Create a Simulator object
#step 3 - Create Tracing and animation file
#step 4 - topography
#step 5 - GOD - General Operations Director
#step 6 - Create nodes
#Step 7 - Create Channel (Communication PATH)
#step 8 - Position of the nodes (Wireless nodes needs a location)
#step 9 - Any mobility codes (if the nodes are moving)
#step 10 - TCP, UDP Traffic
#run the simulation
#initialize the variables
set val(chan) Channel/WirelessChannel ;#Channel Type
set val(prop) Propagation/TwoRayGround ;# radio-propagation model
set val(netif) Phy/WirelessPhy ;# network interface type WAVELAN DSSS 2.4GHz
set val(mac) Mac/802_11 ;# MAC type
set val(ifq) Queue/DropTail/PriQueue ;# interface queue type
set val(ll) LL ;# link layer type
set val(ant) Antenna/OmniAntenna ;# antenna model
set val(ifqlen) 50 ;# max packet in ifq
set val(nn) 6 ;# number of mobilenodes
set val(rp) AODV ;# routing protocol
set val(x) 500 ;# in metres
set val(y) 500 ;# in metres
#Adhoc OnDemand Distance Vector
#creation of Simulator
set ns [new Simulator]
#creation of Trace and namfile
set tracefile [open wireless.tr w]
$ns trace-all $tracefile
#Creation of Network Animation file
set namfile [open wireless.nam w]
$ns namtrace-all-wireless $namfile $val(x) $val(y)
#create topography
set topo [new Topography]
$topo load_flatgrid $val(x) $val(y)
#GOD Creation - General Operations Director
create-god $val(nn)
set channel1 [new $val(chan)]
set channel2 [new $val(chan)]
set channel3 [new $val(chan)]
#configure the node
$ns node-config -adhocRouting $val(rp) \
-llType $val(ll) \
-macType $val(mac) \
-ifqType $val(ifq) \
-ifqLen $val(ifqlen) \
-antType $val(ant) \
-propType $val(prop) \
-phyType $val(netif) \
-topoInstance $topo \
-agentTrace ON \
-macTrace ON \
-routerTrace ON \
-movementTrace ON \
-channel $channel1
set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]
set n3 [$ns node]
set n4 [$ns node]
set n5 [$ns node]
$n0 random-motion 0
$n1 random-motion 0
$n2 random-motion 0
$n3 random-motion 0
$n4 random-motion 0
$n5 random-motion 0
$ns initial_node_pos $n0 20
$ns initial_node_pos $n1 20
$ns initial_node_pos $n2 20
$ns initial_node_pos $n3 20
$ns initial_node_pos $n4 20
$ns initial_node_pos $n5 50
#initial coordinates of the nodes
$n0 set X_ 10.0
$n0 set Y_ 20.0
$n0 set Z_ 0.0
$n1 set X_ 210.0
$n1 set Y_ 230.0
$n1 set Z_ 0.0
$n2 set X_ 100.0
$n2 set Y_ 200.0
$n2 set Z_ 0.0
$n3 set X_ 150.0
$n3 set Y_ 230.0
$n3 set Z_ 0.0
$n4 set X_ 430.0
$n4 set Y_ 320.0
$n4 set Z_ 0.0
$n5 set X_ 270.0
$n5 set Y_ 120.0
$n5 set Z_ 0.0
#Dont mention any values above than 500 because in this example, we use X and Y as 500,500
#mobility of the nodes
#At what Time? Which node? Where to? at What Speed?
$ns at 1.0 "$n1 setdest 490.0 340.0 25.0"
$ns at 1.0 "$n4 setdest 300.0 130.0 5.0"
$ns at 1.0 "$n5 setdest 190.0 440.0 15.0"
#the nodes can move any number of times at any location during the simulation (runtime)
$ns at 20.0 "$n5 setdest 100.0 200.0 30.0"
#creation of agents
set tcp [new Agent/TCP]
set sink [new Agent/TCPSink]
$ns attach-agent $n0 $tcp
$ns attach-agent $n5 $sink
$ns connect $tcp $sink
set ftp [new Application/FTP]
$ftp attach-agent $tcp
$ns at 1.0 "$ftp start"
set udp [new Agent/UDP]
set null [new Agent/Null]
$ns attach-agent $n2 $udp
$ns attach-agent $n3 $null
$ns connect $udp $null
set cbr [new Application/Traffic/CBR]
$cbr attach-agent $udp
$ns at 1.0 "$cbr start"
$ns at 30.0 "finish"
proc finish {} {
global ns tracefile namfile
$ns flush-trace
close $tracefile
close $namfile
exit 0
}
puts "Starting Simulation"
$ns run
AWK FILE
BEGIN {
seqno = -1;
droppedPackets = 0;
receivedPackets = 0;
count = 0;
}
{
#packet delivery ratio
if($4 == "AGT" && $1 == "s" && seqno < $6) {
seqno = $6;
} else if(($4 == "AGT") && ($1 == "r")) {
receivedPackets++;
} else if ($1 == "D" && $7 == "tcp" && $8 > 512){
droppedPackets++;
}
#end-to-end delay
if($4 == "AGT" && $1 == "s") {
start_time[$6] = $2;
} else if(($7 == "tcp") && ($1 == "r")) {
end_time[$6] = $2;
} else if($1 == "D" && $7 == "tcp") {
end_time[$6] = -1;
}
}
END {
for(i=0; i<=seqno; i++) {
if(end_time[i] > 0) {
delay[i] = end_time[i] - start_time[i];
count++;
} else {
delay[i] = -1;
}
}
for(i=0; i<count; i++) {
if(delay[i] > 0) {
n_to_n_delay = n_to_n_delay + delay[i];
}
}
n_to_n_delay = n_to_n_delay/count;
print "\n";
print "GeneratedPackets = " seqno+1;
print "ReceivedPackets = " receivedPackets;
print "Packet Delivery Ratio = "receivedPackets/(seqno+1)*100"%";
print "Total Dropped Packets = " droppedPackets;
print "Average End-to-End Delay = " n_to_n_delay * 1000 " ms";
print "\n";
}

--------------------------------------------
DHCPSERVER VER2
import java.io.*;
import java.util.*;
import java.net.*;

class DHCPServer {
    static int sp = 4900; // Server Port
    static String file = "ip.txt"; // File to store allocated IP addresses
    String sip = "127.0.0.1"; // Server IP
    static List<String> ipaddr = new ArrayList<>();

    public static void main(String[] args) {
        // Initialize IP pool
        Initialize();
        
        try {
            // Create DatagramSocket to listen for requests on port 'sp'
            DatagramSocket socket = new DatagramSocket(sp);
            
            while (true) {
                // Receive the client's request
                byte[] receive = new byte[1024];
                DatagramPacket packet = new DatagramPacket(receive, receive.length);
                socket.receive(packet); // Wait for a request
                
                // Get client's address
                InetAddress clientaddr = packet.getAddress();
                String mac = "00:11:22:33:44:55"; // Mocked MAC address
                
                // Allocate an IP address to the client
                String allocIp = allocate();
                
                // Prepare and send the response to the client
                byte[] response = ("Allocated IP: " + allocIp).getBytes();
                DatagramPacket responsepack = new DatagramPacket(response, response.length, clientaddr, packet.getPort());
                socket.send(responsepack);
                
                // Log the allocation
                System.out.println("Allocated IP: " + allocIp + " to client MAC: " + mac);
                
                // Save the allocated IP to the file
                saveIpAlloc(allocIp);
            }
        } catch (Exception e) {
            System.out.println("Server not created properly: " + e.getMessage());
        }
    }

    // Initialize IP pool with available IP addresses (from 192.168.1.2 to 192.168.1.254)
    static void Initialize() {
        for (int i = 2; i <= 254; i++) {
            ipaddr.add("192.168.1." + i);
        }
    }

    // Allocate an IP address from the pool randomly
    static String allocate() {
        Random r = new Random();
        int i = r.nextInt(ipaddr.size()); // Randomly pick an IP
        String s1 = ipaddr.remove(i); // Remove the allocated IP from the pool
        return s1;
    }

    // Save the allocated IP address to a file
    static void saveIpAlloc(String a) {
        try (BufferedWriter br = new BufferedWriter(new FileWriter(file, true))) {
            br.write("IP: " + a);
            br.newLine();
            System.out.println("Saved IP allocation to file.");
        } catch (Exception e) {
            System.out.println("IP allocation not written to file properly: " + e.getMessage());
        }
    }
}


import java.net.*;
import java.util.*;

class DHCPClient {
    static int sp = 4900; // Server port
    static String sip = "127.0.0.1"; // Server IP
    static String mac = "00:11:22:33:44:55"; // Client MAC address

    public static void main(String[] args) {
        try {
            // Create a DatagramSocket to send and receive data
            DatagramSocket socket = new DatagramSocket();
            
            // Get the server address (DHCP server's IP)
            InetAddress serveraddr = InetAddress.getByName(sip);
            
            // Create the DHCP request message with the client's MAC address
            byte[] response = ("DHCP with MAC: " + mac).getBytes();
            DatagramPacket pack = new DatagramPacket(response, response.length, serveraddr, sp);
            
            // Send the DHCP request to the server
            socket.send(pack);
            
            // Prepare to receive the DHCP response from the server
            byte[] receive = new byte[1024];
            DatagramPacket packet = new DatagramPacket(receive, receive.length);
            socket.receive(packet); // Wait for the response
            
            // Convert the response bytes into a string and print it
            String res = new String(packet.getData()).trim();
            System.out.println("Received DHCP response: " + res);
        } catch (Exception e) {
            System.out.println("Not connected: " + e.getMessage());
        }
    }
}
-------------------------------------------
EXP 11 GCR 
Mac/802_11 set dataRate_ 1Mb
set val(chan) Channel/WirelessChannel ;# channel type
set val(prop) Propagation/TwoRayGround ;# radio-propagation model

set val(ant) Antenna/OmniAntenna ;# Antenna type
set val(ll) LL ;# Link layer type
set val(ifq) Queue/DropTail/PriQueue ;# Interface queue type
set val(ifqlen) 50 ;# max packet in ifq
set val(netif) Phy/WirelessPhy ;# network interface type
set val(mac) Mac/802_11 ;# MAC type
set val(nn) 15 ;# number of mobilenodes
set val(rp) AODV ;# routing protocol
set val(x) 800
set val(y) 800

# Creating simulation object
set ns [new Simulator]

#creating Output trace files
set f [open complexdcf.tr w]
$ns trace-all $f

set namtrace [open complexdcf.nam w]
$ns namtrace-all-wireless $namtrace $val(x) $val(y)

set f0 [open C_DCF_AT.tr w]

set topo [new Topography]
$topo load_flatgrid 800 800
# Defining Global Variables
create-god $val(nn)
set chan_1 [new $val(chan)]
# setting the wireless nodes parameters
$ns node-config -adhocRouting $val(rp) \
-llType $val(ll) \
-macType $val(mac) \
-ifqType $val(ifq) \
-ifqLen $val(ifqlen) \
-antType $val(ant) \
-propType $val(prop) \
-phyType $val(netif) \
-topoInstance $topo \
-agentTrace OFF \
-routerTrace ON \
-macTrace ON \
-movementTrace OFF \
-channel $chan_1 

proc finish {} {
global ns f f0 namtrace# global variables
# Closing the trace files
$ns flush-trace
#close $namtrace
close $f0
exec nam -r 5m complexdcf.nam & # Running the animator
exit 0
}
# Defining a procedure to calculate the througpout
proc record {} {
global sink1 sink3 sink7 sink10 sink11 f0
set ns [Simulator instance]
set time 0.5
set bw0 [$sink3 set bytes_]
set bw3 [$sink3 set bytes_]
set bw7 [$sink7 set bytes_]
set bw10 [$sink10 set bytes_]
set bw11 [$sink11 set bytes_]
set now [$ns now]
puts $f0 "$now [expr ($bw0+$bw3+$bw7+$bw10+$bw11)/$time*8/1000000]"
# Calculating the average throughput

$sink1 set bytes_ 0
$sink3 set bytes_ 0
$sink7 set bytes_ 0
$sink10 set bytes_ 0
$sink11 set bytes_ 0
$ns at [expr $now+$time] "record"
}
#Creating the wireless Nodes
for {set i 0} {$i < $val(nn) } {incr i} {
set n($i) [$ns node]
$n($i) random-motion 0 ;
}
#setting the initial position for the nodes
for {set i 0} {$i < $val(nn)} {incr i} {
$ns initial_node_pos $n($i) 30+i*100
}
for {set i 0} {$i < $val(nn)} {incr i} {
$n($i) set X_ 0.0
$n($i) set Y_ 0.0
$n($i) set Z_ 0.0
}
# making some nodes move in the topography
$ns at 0.0 "$n(0) setdest 100.0 100.0 3000.0"
$ns at 0.0 "$n(1) setdest 200.0 200.0 3000.0"
$ns at 0.0 "$n(2) setdest 300.0 200.0 3000.0"
$ns at 0.0 "$n(3) setdest 400.0 300.0 3000.0"
$ns at 0.0 "$n(4) setdest 500.0 300.0 3000.0"
$ns at 0.0 "$n(5) setdest 600.0 400.0 3000.0"
$ns at 0.0 "$n(6) setdest 600.0 100.0 3000.0"
$ns at 0.0 "$n(7) setdest 600.0 200.0 3000.0"

$ns at 0.0 "$n(8) setdest 600.0 300.0 3000.0"
$ns at 0.0 "$n(9) setdest 600.0 350.0 3000.0"
$ns at 0.0 "$n(10) setdest 700.0 100.0 3000.0"
$ns at 0.0 "$n(11) setdest 700.0 200.0 3000.0"
$ns at 0.0 "$n(12) setdest 700.0 300.0 3000.0"
$ns at 0.0 "$n(13) setdest 700.0 350.0 3000.0"
$ns at 0.0 "$n(14) setdest 700.0 400.0 3000.0"
$ns at 2.0 "$n(5) setdest 100.0 400.0 500.0"
$ns at 1.5 "$n(3) setdest 450.0 150.0 500.0"
$ns at 50.0 "$n(7) setdest 300.0 400.0 500.0"
$ns at 2.0 "$n(10) setdest 200.0 400.0 500.0"
$ns at 2.0 "$n(11) setdest 650.0 400.0 500.0"
#Creating receiving sinks with monitoring ability to monitor the incoming bytes
# LossMonitor objects are a subclass of agent objects that implement a traffic sink.
set sink1 [new Agent/LossMonitor]
set sink3 [new Agent/LossMonitor]
set sink7 [new Agent/LossMonitor]
set sink10 [new Agent/LossMonitor]
set sink11 [new Agent/LossMonitor]
$ns attach-agent $n(1) $sink1
$ns attach-agent $n(3) $sink3
$ns attach-agent $n(7) $sink7
$ns attach-agent $n(10) $sink10
$ns attach-agent $n(11) $sink11
# setting TCP as the transmission protocol over the connections
set tcp0 [new Agent/TCP]
$ns attach-agent $n(0) $tcp0
set tcp2 [new Agent/TCP]
$ns attach-agent $n(2) $tcp2
set tcp4 [new Agent/TCP]

$ns attach-agent $n(4) $tcp4
set tcp5 [new Agent/TCP]
$ns attach-agent $n(5) $tcp5
set tcp9 [new Agent/TCP]
$ns attach-agent $n(9) $tcp9
set tcp13 [new Agent/TCP]
$ns attach-agent $n(13) $tcp13
set tcp6 [new Agent/TCP]
$ns attach-agent $n(6) $tcp6
set tcp14 [new Agent/TCP]
$ns attach-agent $n(14) $tcp14
set tcp8 [new Agent/TCP]
$ns attach-agent $n(8) $tcp8
set tcp12 [new Agent/TCP]
$ns attach-agent $n(12) $tcp12
# Setting FTP connections
set ftp9 [new Application/FTP]
$ftp9 attach-agent $tcp9
$ftp9 set type_ FTP
set ftp13 [new Application/FTP]
$ftp13 attach-agent $tcp13
$ftp13 set type_ FTP
set ftp6 [new Application/FTP]
$ftp6 attach-agent $tcp6
$ftp6 set type_ FTP
set ftp14 [new Application/FTP]
$ftp14 attach-agent $tcp14
$ftp14 set type_ FTP
set ftp8 [new Application/FTP]
$ftp8 attach-agent $tcp8

$ftp8 set type_ FTP
set ftp12 [new Application/FTP]
$ftp12 attach-agent $tcp12
$ftp12 set type_ FTP
#connecting the nodes
$ns connect $tcp0 $sink3
$ns connect $tcp5 $sink3
$ns connect $tcp2 $sink1
$ns connect $tcp4 $sink1
$ns connect $tcp9 $sink7
$ns connect $tcp13 $sink7
$ns connect $tcp6 $sink10
$ns connect $tcp14 $sink10
$ns connect $tcp8 $sink11
$ns connect $tcp12 $sink11
# Defining CBR procedure with the required parametes
proc attach-CBR-traffic { node sink size interval } {
set ns [Simulator instance]
set cbr [new Agent/CBR]
$ns attach-agent $node $cbr
$cbr set packetSize_ $size
$cbr set interval_ $interval
$ns connect $cbr $sink
return $cbr
}
#attach-CBR-traffic { node sink size interval }
set cbr0 [attach-CBR-traffic $n(0) $sink3 1000 .015]
set cbr1 [attach-CBR-traffic $n(5) $sink3 1000 .015]
set cbr2 [attach-CBR-traffic $n(2) $sink1 1000 .015]
set cbr3 [attach-CBR-traffic $n(4) $sink1 1000 .015]
# Setting the begining and ending time of each connection

$ns at 0.0 "record"
$ns at 20.0 "$cbr0 start"
$ns at 20.0 "$cbr2 start"
$ns at 800.0 "$cbr0 stop"
$ns at 850.0 "$cbr2 stop"
$ns at 30.0 "$cbr1 start"
$ns at 30.0 "$cbr3 start"
$ns at 850.0 "$cbr1 stop"
$ns at 870.0 "$cbr3 stop"
$ns at 25.0 "$ftp6 start"
$ns at 25.0 "$ftp14 start"
$ns at 810.0 "$ftp6 stop"
$ns at 860.0 "$ftp14 stop"
$ns at 35.0 "$ftp9 start"
$ns at 35.0 "$ftp13 start"
$ns at 830.0 "$ftp9 stop"
$ns at 889.0 "$ftp13 stop"
$ns at 40.0 "$ftp8 start"
$ns at 40.0 "$ftp12 start"
$ns at 820.0 "$ftp8 stop"
$ns at 890.0 "$ftp12 stop"
$ns at 900.0 "finish"
# Runnning the simulation
puts "Start of simulation.."
$ns run
