Ex-1
/* System Calls needed to understand are: pipe()/pipe2() and fork() */

#include<stdio.h>
#include<sys/types.h>
#include<unistd.h> /* pipe(), pipe2() */

int main()
{

	int p[2];
	pid_t pid;

	char inbuf[10],outbuf[10];
 
	if(pipe(p)==-1)  /*  p[0] - Read End,         p[1] - Write End   */
	{
		printf("\nPipe Creation failed....\n");
		return 1;
	}
	else
		printf("\nInter-Process Communication PIPE is created...\n");

	pid=fork();

	if(pid>0) /*i.e., Parent*/
	{
		printf("\n\nChild Process Created Successfully with ID:%d",pid);
		printf("\n\nIn Parent Process: (Process ID: %d): \n",getpid());
		printf("\nEnter the Data to be sent to child: ");
               	scanf("%s",outbuf);
		write (p[1],outbuf,10);
		//sleep(10);
		//printf("\nAfter Sleep in Parent Process...\n");
        }
	else if(pid==0)	/*i.e., Child*/
	{
		sleep(10);
		printf("\n\nIn Child Process: (Process ID: %d):  Waiting for Data From Parent...\n",getpid());
		read(p[0],inbuf,10);
		printf("\nThe Data received by the Child(P-%d) From Parent(P-%d) is: %s\n",getpid(),getppid(),inbuf);
		//sleep(2);
		//printf("After sleep in child\n");
	}
	else 		/*if -1, child process creation error*/
	{
		printf("\n\nNo Child Process is Created....");
		printf("\nPrcess Creation Errorrrrrr...");
		printf("\nBetter Luck Next Time....");
		return 1;
	}

	return 0;
}


__________________________________________________________________________________________________________________

Ex-2

shared memory

shm_server.c
#include <iostream>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
using namespace std;
int main()
{
// ftok to generate unique key
key_t key = ftok("shmfile",65);
// shmget creates shared memory and returns an identifier in shmid
int shmid = shmget(key,1024,0666|IPC_CREAT);
// shmat to attach to shared memory
char *str = (char*) shmat(shmid,(void*)0,0);
cout<<"Write Data : ";
gets(str);
printf("Data written in memory: %s\n",str);
//detach from shared memory
shmdt(str);
return 0;
}
shm_client.c
#include <iostream>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
using namespace std;
int main()
{
// ftok to generate same key of the server
key_t key = ftok("shmfile",65);
// shmget returns an identifier in shmid
int shmid = shmget(key,1024,0666|IPC_CREAT);
// shmat to attach to shared memory
char *str = (char*) shmat(shmid,(void*)0,0);
printf("Data read from memory: %s\n",str);
//detach from shared memory
shmdt(str);
// destroy the shared memory
shmctl(shmid,IPC_RMID,NULL);
return 0;
}


Message Queue

server.c
//Message Queue Sender
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
// Define message structure
struct msgbuf {
    long mtype;
    char mtext[100];
};
int main(void)
{
    int mqID;
    key_t key;
    struct msgbuf buf;
    key = 333;
    if ((mqID = msgget(key, 0666 | IPC_CREAT)) == -1) {
        perror("msgget");
        exit(1);
    }
    
    printf("\nMessage Queue Created...");
    while (1) {
        printf("\n\nEnter Message: ");
        fgets(buf.mtext, sizeof(buf.mtext), stdin);
        buf.mtext[strcspn(buf.mtext, "\n")] = '\0';  // Remove newline character from fgets
        buf.mtype = 1;  // Set message type
        if (msgsnd(mqID, &buf, sizeof(buf.mtext), 0) == -1) {
            perror("msgsnd");
        }
        if (strcmp(buf.mtext, "bye") == 0) {
            break;
        }
    }
    msgctl(mqID, IPC_RMID, NULL);
    printf("\n\nExited....\n\n");
    return 0;
}



client.c
//Message Queue receiver code
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

// Define message structure
struct msgbuf {
    long mtype;
    char mtext[100];
};

int main(void)
{
    int mqID;
    key_t key;
    struct msgbuf buf;

    key = 333;

    if ((mqID = msgget(key, 0666)) == -1) {
        perror("msgget");
        exit(1);
    }
    
    printf("\nMessage Queue Created...");
 
    while (1)
    {
        printf("\n\nWaiting For Message From Sender....");	

        if (msgrcv(mqID, &buf, sizeof(buf.mtext), 0, 0) == -1) {
            perror("msgrcv");
            exit(1);
        }

        printf("\nMessage Received: %s", buf.mtext);

        if (strcmp(buf.mtext, "bye") == 0)
            break;
    }

    msgctl(mqID, IPC_RMID, NULL);

    printf("\n\nExited....\n\n");
    return 0;
}












________________________________________________________________________________________
CPU SCHEDULING PROGRAMS
****************************************************************************************************************************************************************************************
Round Robin

#include<stdio.h>
struct process
{
	int at;
	int st;
	int ft;
	int status;
} ready[10];
int n,t,com=0;
int Dispatch(int ct)
{
	int i,index=-1,high_at=0,high_status=0; //high_status- 0- Not yet execsted once, 1- already executed atleast once
	int m;
	m=n;
	for(i=0; i<n; i++)
	{
		if(ready[i].at> high_at)
		{
			high_at=ready[i].at;
		}
	}
	for(i=0; i<n; i++)
	{
		if(ready[i].status > high_status)
		{
			high_status=ready[i].status;
		}
	}
	for(i=0; i<n; i++)
	{
		if(ready[i].status!=2) //Status = 2 means process already completed
		{
			if(ready[i].at<=ct)
			{
				if(ready[i].at<high_at)
				{
					index=i;
					high_at=ready[i].at;
				}
				if(ready[i].at==high_at)
				{
					if(ready[i].status<high_status)
					{
						index=i;
						high_status=ready[i].status;
					}
					else if(ready[i].status==high_status)
					{
						if(i<m)
						{
							index=i;
							m=i;
						}
					}
				}
			}
		}
	}
	return index;
}
int main()
{
	int i;
	printf("Enter number of processes:");
	scanf("%d",&n);
	printf("Enter the time slice:");
	scanf("%d",&t);
	for(i=0; i<n; i++)
	{
		printf("Process:%d\n",i+1);
		printf("\n");
		printf("Enter the arrival time:");
		scanf("%d",&ready[i].at);
		printf("Enter the service time:");
		scanf("%d",&ready[i].st);
		ready[i].status=0;
	}
	i=0;
	int at[10],st[10];
	for(i=0; i<n; i++)
	{
		at[i]=ready[i].at;
		st[i]=ready[i].st;
	}
	int pid,cur_time=0;
	while(com<n)
	{
		pid=Dispatch(cur_time);
		if(ready[pid].st<=t)
		{
			cur_time+=ready[pid].st;
			ready[pid].ft=cur_time;
			ready[pid].status=2;
			com++;
		}
		else
		{
			cur_time+=t;
			ready[pid].at=cur_time;
			ready[pid].st=ready[pid].st-t;
			ready[pid].status=1;
		}
	}
	cur_time+=t;
	ready[pid].at=cur_time;
	ready[pid].st=ready[pid].st-t;
	ready[pid].status=1;
	printf("process-id\t arrival time\t service time\t finish time\t turnaround time\twaitingtime\n");
	printf("\n");
	for(i=0; i<n; i++) {
	printf("%d\t\t %d\t\t\t %d\t\t %d\t\t %d\t\t\t%d\n",i+1,at[i],st[i],ready[i].ft,ready[i].ft-at[i],ready[i].ft-at[i]-st[i]);
	}
}

****************************************************************************************************************************************************************************************
FCFS
#include <stdio.h>
struct process
{
	int at;
	int st;
	int status;
	int ft;
} ready_list[10];
int n;
int dispatcher(int time)
{
	int i,lat = time,index=-1;
	for(i=0; i<n; i++)
	{
	}
	if(ready_list[i].status != 1) {
		if(ready_list[i].at <= lat)
		{
			lat = ready_list[i].at;
			index=i;
		}
	}
	return index;
}
int main()
{
	int i,cur_time,pid;
	printf("Enter number of processes:");
	scanf("%d",&n);
// Collect process details
	for(i=0; i<n; i++)
	{
		printf("Process %d\n",i+1);
		printf("***********\n");
		printf("Enter Arrival Time:");
		scanf("%d",&ready_list[i].at);
		printf("Enter Service Time:");
		scanf("%d",&ready_list[i].st);
		ready_list[i].status=0;
	}
	i=0;
	cur_time=0;
	while(i < n)
	{
		pid=dispatcher(cur_time);
		while(pid==-1) {
			cur_time++;
			pid = dispatcher(cur_time);
		}
		ready_list[pid].ft=cur_time + ready_list[pid].st;
		ready_list[pid].status=1;
		cur_time+= ready_list[pid].st;
		i++;
	}
	printf("Process\t Arrival Time\t Burst Time\tFinish Time \t TT \t\t WT\n");
	printf("*******\t ************\t ************\t ***********\t********\t********\n");
	for(i=0; i<n; i++)
	{
		printf("%d\t\t%d\t\t%d\t\t%d\t%d\t\t%d\n",i+1,ready_list[i].at,ready_list[i].st,ready_l
		       ist[i].ft, (ready_list[i].ft-ready_list[i].at),(ready_list[i].ft-ready_list[i].at)-ready_list[i].st);
	}
}

****************************************************************************************************************************************************************************************
SJF

#include <stdio.h>
#include<limits.h>
struct process
{
	int at;
	int st;
	int status;
	int ft;
} ready_list[10];
int n;
int dispatcher(int time)
{
	int i,bt = INT_MAX,index=-1;
	for(i=0; i<n; i++)
	{
		if(ready_list[i].status != 1)
			if(ready_list[i].at <= time)
				if(ready_list[i].st<=bt)
				{
					bt = ready_list[i].st;
					index=i;
				}
	}
	return index;
}
int main()
{
	int i,cur_time,pid;
	printf("Enter number of processes:");
	scanf("%d",&n);
// Collect process details
	for(i=0; i<n; i++)
	{
		printf("Process %d\n",i+1);
		printf("***********\n");
		printf("Enter Arrival Time:");
		scanf("%d",&ready_list[i].at);
		printf("Enter Service Time:");
		scanf("%d",&ready_list[i].st);
		ready_list[i].status=0;
	}
	i=0;
	cur_time=0;
	while(i < n)
	{
		pid=dispatcher(cur_time);
		while(pid==-1) {
			cur_time++;
			pid = dispatcher(cur_time);
		}
		ready_list[pid].ft=cur_time + ready_list[pid].st;
		ready_list[pid].status=1;
		cur_time+= ready_list[pid].st;
		i++;
	}
	printf("Process\t Arrival Time\t Burst Time\tFinish Time \t TT \t\t WT\n");
	printf("*******\t ************\t ************\t ***********\t********\t********\n");
	for(i=0; i<n; i++)
	{
		printf("%d\t\t%d\t\t%d\t\t%d\t%d\t\t%d\n",i+1,ready_list[i].at,ready_list[i].st,ready_list[i].ft, (ready_list[i].ft-ready_list[i].at),(ready_list[i].ft-ready_list[i].at)-ready_list[i].st);
	}
}
****************************************************************************************************************************************************************************************

SRTJF
#include <stdio.h>
struct process
{
	int at;
	int st;
	int status;
	int ft;
} ready_list[10];
int n;
int dispatcher(int time)
{
	int i,s_bt=9999,index=-1;
	for(i=0; i<n; i++)
	{
		if(ready_list[i].status != 1)
			if(ready_list[i].at <= time)
				if(ready_list[i].st < s_bt)
				{
					s_bt = ready_list[i].st;
					index=i;
				}
	}
	return index;
}
int main()
{
	int i,cur_time,pid;
	int rem_procs=0;
	printf("Enter number of processes:");
	scanf("%d",&n);
// Collect process details
	for(i=0; i<n; i++)
	{
		printf("Process %d\n",i+1);
		printf("***********\n");
		printf("Enter Arrival Time:");
		scanf("%d",&ready_list[i].at);
		printf("Enter Burst Time:");
		scanf("%d",&ready_list[i].st);
		ready_list[i].status=0;
	}
	int bd[n];
	for(i=0; i<n; i++) {
		bd[i] = ready_list[i].st;
	}
	cur_time=0;
	while(rem_procs < n)
	{
		pid=dispatcher(cur_time);
		ready_list[pid].ft=cur_time + 1;
		cur_time = cur_time + 1;
		ready_list[pid].st-=1;
		if(ready_list[pid].st==0)
		{
			ready_list[pid].status=1;
			rem_procs+=1;
		}
	}
	printf("Process\t Arrival Time\t Burst Time\t Finish Time");
	printf("*******\t **********\t **********\t *********\n");
	for(i=0; i<n; i++)
	{
		printf("%d\t\t%d\t\t%d\t\t\t%d\n",i,ready_list[i].at,bd[i],ready_list[i].ft);
	}
}

****************************************************************************************************************************************************************************************



________________________________________________________________________________________________


//Multithreading

#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<pthread.h>

void *calcPrime(void *inp){
	int *input = (int *)inp;
	int flags = 0;	
	for(int i=2; i<=*input/2; i++){
		if(*input%i == 0){
			flags++;
			break;
		}
	}
	if(flags == 0){
		printf("%d is a prime number \n",*input);
	}else{
		printf("%d is not a prime number \n",*input);
	}
}

void *armstrong(void *inp){
	int *input = (int *)inp;
	int temp = *input;
	int n = 0;
	float res = 0.0;
	for(temp = *input; temp!=0; ++n){
		temp/=10;
	}
	for(temp = *input; temp!=0; temp/=10){
		int remainder = temp % 10;
		int tempres = 1;
		for(int j=0; j<n; j++){
			tempres *= remainder;
		}
		res += tempres;
	}
	if((int)res == *input){
		printf("%d is an armstrong \n", *input);
	}else{
		printf("%d is not an armstrong \n", *input);
	}
}

void *factorial(void *inp){
	int *input = (int *)inp;
	long long int res = 1;
	for(int i=1; i<=*input; i++){
		res*=i;
	}
	printf("Factorial of %d is %lld \n", *input, res);
}

int main(){
	pthread_t threads[6];
	int n;
	while(1>0){
		printf("Enter your value:- \n");
		scanf("%d", &n);
		pthread_create(&threads[0], NULL, calcPrime, (void *)&n);
		pthread_create(&threads[1], NULL, factorial, (void *)&n);
		pthread_create(&threads[2], NULL, armstrong, (void *)&n);
		pthread_join(threads[0], NULL);
		pthread_join(threads[1], NULL);
		pthread_join(threads[2], NULL);
	}
	exit(0);
}




Pthread


Version 1


#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>


// Define the thread data structure
typedef struct {
    int *array;
    int start;
    int end;
    int search;
    int *count;
    pthread_mutex_t *mutex;  // Mutex to synchronize count updates
} ThreadData;


// Thread function to search for occurrences of 'search' in a segment of the array
void* search_scores(void* arg) {
    ThreadData *data = (ThreadData*) arg;
    int local_count = 0;


    for (int i = data->start; i < data->end; i++) {
        if (data->array[i] == data->search) {
            local_count++;
        }
    }


    // Lock the mutex before updating the shared count
    pthread_mutex_lock(data->mutex);
    *(data->count) += local_count;
    pthread_mutex_unlock(data->mutex);


    return NULL;
}


int main(int argc, char *argv[]) {
    if (argc != 5) {
        fprintf(stderr, "Usage: %s <file> <S> <threads> <segment_size>\n", argv[0]);
        return EXIT_FAILURE;
    }


    const char *filename = argv[1];
    int search_value = atoi(argv[2]);
    int num_threads = atoi(argv[3]);
    int segment_size = atoi(argv[4]);


    // Open the file
    FILE *file = fopen(filename, "r");
    if (!file) {
        perror("fopen");
        return EXIT_FAILURE;
    }


    // Read scores into an array
    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    fseek(file, 0, SEEK_SET);


    int num_scores = file_size / sizeof(int);
    int *scores = malloc(file_size);
    fread(scores, sizeof(int), num_scores, file);
    fclose(file);


    // Create threads and perform search
    pthread_t threads[num_threads];
    pthread_mutex_t mutex;
    pthread_mutex_init(&mutex, NULL);
    int count = 0;


    // Create threads
    for (int i = 0; i < num_threads; i++) {
        ThreadData *data = malloc(sizeof(ThreadData));
        data->array = scores;
        data->start = i * segment_size;
        data->end = (i + 1) * segment_size;
        if (data->end > num_scores) data->end = num_scores; // Handle last segment
        data->search = search_value;
        data->count = &count;
        data->mutex = &mutex;


        pthread_create(&threads[i], NULL, search_scores, data);
    }


    // Join threads
    for (int i = 0; i < num_threads; i++) {
        pthread_join(threads[i], NULL);
    }


    // Print result
    printf("Number of students who scored %d: %d\n", search_value, count);


    // Clean up
    pthread_mutex_destroy(&mutex);
    free(scores);


    return EXIT_SUCCESS;
}




Version 2


#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>


#define MAX_SCORE 100


typedef struct {
    int *scores;
    int start;
    int end;
    int target;
    int count;
} ThreadData;


void *search_score(void *arg) {
    ThreadData *data = (ThreadData *)arg;
    int count = 0;
    for (int i = data->start; i < data->end; i++) {
        if (data->scores[i] == data->target) {
            count++;
        }
    }
    data->count = count;
    return NULL;
}


int main() {
    int N, M, S;
    printf("Enter the number of students (N): ");
    scanf("%d", &N);
    printf("Enter the number of threads (M): ");
    scanf("%d", &M);
    printf("Enter the score to search for (S): ");
    scanf("%d", &S);


    // Allocate memory for student scores
    int *scores = (int *)malloc(N * sizeof(int));
    if (scores == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }


    // Generate random scores for students
    srand(time(NULL));
    for (int i = 0; i < N; i++) {
        scores[i] = rand() % (MAX_SCORE + 1);
    }


    // Divide work among threads
    pthread_t threads[M];
    ThreadData thread_data[M];
    int segment_size = N / M;


    for (int i = 0; i < M; i++) {
        thread_data[i].scores = scores;
        thread_data[i].start = i * segment_size;
        thread_data[i].end = (i == M - 1) ? N : (i + 1) * segment_size;
        thread_data[i].target = S;
        thread_data[i].count = 0;


        pthread_create(&threads[i], NULL, search_score, &thread_data[i]);
    }


    // Aggregate results from all threads
    int total_count = 0;
    for (int i = 0; i < M; i++) {
        pthread_join(threads[i], NULL);
        total_count += thread_data[i].count;
    }


    printf("Number of students who scored %d: %d\n", S, total_count);


    // Free allocated memory
    free(scores);


    return 0;
}














Peterson 2 process


#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <stdbool.h>
#define NUM_SEATS 100
int totalSeats = NUM_SEATS;
int choosing[2] = {0, 0};
int turn = 0;
void* server(void* arg) {
while (true) {
int choice;
printf("Server: Total seats available: %d\n", totalSeats);
printf("Server: Waiting for client input (0 to exit, 1 to book, 2 to cancel): ");
scanf("%d", &choice);
if (choice == 0) {


break;
} else if (choice == 1) {
int count;
printf("Server: Enter the number of seats to book: ");
scanf("%d", &count);
// Critical Section
choosing[0] = 1;
turn = 1;
while (choosing[1] && turn == 1);
// Enter critical section
if (count <= totalSeats) {
totalSeats -= count;
printf("Server: %d seat(s) booked. Total seats available: %d\n", count, totalSeats);
} else {
printf("Server: Not enough seats available for booking.\n");
}
// Exit critical section
choosing[0] = 0;
} else if (choice == 2) {
int count;
printf("Server: Enter the number of seats to cancel: ");
scanf("%d", &count);
// Critical Section
choosing[0] = 1;
turn = 1;
while (choosing[1] && turn == 1);
// Enter critical section
totalSeats += count;
printf("Server: %d seat(s) canceled. Total seats available: %d\n", count, totalSeats);
// Exit critical section
choosing[0] = 0;
} else {
printf("Server: Invalid choice. Try again.\n");
}
}
pthread_exit(NULL);
}


void* client(void* arg) {
while (true) {
int choice;
printf("Client: Waiting for your choice (0 to exit, 1 to book, 2 to cancel): ");
scanf("%d", &choice);
if (choice == 0) {
break;
} else if (choice == 1 || choice == 2) {
int count;
printf("Client: Enter the number of seats: ");
scanf("%d", &count);
if (count >= 0) {
// Critical Section
choosing[1] = 1;
turn = 0;
while (choosing[0] && turn == 0);
// Enter critical section
if (choice == 1) {
printf("Client: Request to book %d seat(s).\n", count);
} else {
printf("Client: Request to cancel %d seat(s).\n", count);
}
// Exit critical section
choosing[1] = 0;
} else {
printf("Client: Invalid number of seats. Try again.\n");
}
} else {
printf("Client: Invalid choice. Try again.\n");
}
}
pthread_exit(NULL);
}
int main() {
pthread_t server_thread, client_thread;
pthread_create(&server_thread, NULL, server, NULL);
pthread_create(&client_thread, NULL, client, NULL);


pthread_join(server_thread, NULL);
pthread_join(client_thread, NULL);
printf("Program exiting...\n");
return 0;
}




Peterson n process




#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>


#define MAX_PROCESSES 10


int num_seats = 0;
int choosing[MAX_PROCESSES];
int number[MAX_PROCESSES];
int n;  // Number of processes


pthread_mutex_t input_mutex = PTHREAD_MUTEX_INITIALIZER;  // Mutex for synchronizing input operations


void enter_critical_section(int process_id) {
    for (int i = 0; i < n; i++) {
        if (i != process_id) {
            choosing[process_id] = 1;
            number[process_id] = 1 + (number[i] > number[process_id] ? number[i] : number[process_id]);
            choosing[process_id] = 0;
            while (choosing[i]) ;
            while (number[i] != 0 && (number[i] < number[process_id] || (number[i] == number[process_id] && i < process_id))) ;
        }
    }
}


void leave_critical_section(int process_id) {
    number[process_id] = 0;
}


void* process(void* arg) {
    int process_id = *(int*)arg;
    int choice, count;


    while (1) {
        pthread_mutex_lock(&input_mutex);  // Lock for input synchronization


        printf("Process %d: Enter 1 to book seats, 2 to cancel seats, 0 to exit: ", process_id);
        scanf("%d", &choice);


        if (choice == 0) {
            pthread_mutex_unlock(&input_mutex);  // Unlock before exiting
            pthread_exit(NULL);
        }


        if (choice == 1 || choice == 2) {
            printf("Process %d: Enter number of seats: ", process_id);
            scanf("%d", &count);


            if (count < 0) {
                printf("Process %d: Invalid number of seats. Try again.\n", process_id);
                pthread_mutex_unlock(&input_mutex);  // Unlock before continuing
                continue;
            }


            enter_critical_section(process_id);


            if (choice == 1) {
                if (count <= num_seats) {
                    num_seats -= count;
                    printf("Process %d: %d seat(s) booked. Total seats available: %d\n", process_id, count, num_seats);
                } else {
                    printf("Process %d: Not enough seats available for booking.\n", process_id);
                }
            } else if (choice == 2) {
                num_seats += count;
                printf("Process %d: %d seat(s) canceled. Total seats available: %d\n", process_id, count, num_seats);
            }


            leave_critical_section(process_id);
        } else {
            printf("Process %d: Invalid choice. Try again.\n", process_id);
        }


        pthread_mutex_unlock(&input_mutex);  // Unlock after processing input
    }
    return NULL;
}


int main() {
    pthread_t threads[MAX_PROCESSES];
    int process_ids[MAX_PROCESSES];


    printf("Enter the total number of seats: ");
    scanf("%d", &num_seats);


    printf("Enter the number of processes (1 to %d): ", MAX_PROCESSES);
    scanf("%d", &n);


    if (n < 1 || n > MAX_PROCESSES) {
        printf("Invalid number of processes.\n");
        return 1;
    }


    for (int i = 0; i < n; i++) {
        choosing[i] = 0;
        number[i] = 0;
        process_ids[i] = i;
        pthread_create(&threads[i], NULL, process, &process_ids[i]);
    }


    for (int i = 0; i < n; i++) {
        pthread_join(threads[i], NULL);
    }


    pthread_mutex_destroy(&input_mutex);  // Destroy the mutex
    printf("Program exiting...\n");
    return 0;
}












Producer Consumer








server.c


#include <stdio.h>
#include <stdlib.h>
#include<sys/shm.h>
#include<sys/types.h>
#include<sys/ipc.h>


int main() {
    key_t k1, k2, k3, k4;
    k1 = 9999;
    k3 = 9997; 
    k4 = 9996; 


    int mutexid, inid, outid;
    if((mutexid = shmget(k1, sizeof(int), 0666 | IPC_CREAT)) == -1) {
        perror("SHMGET");
        exit(1);
    }
    
    if((inid = shmget(k3, sizeof(int), 0666 | IPC_CREAT)) == -1) {
        perror("SHMGET");
        exit(1);
    }
    if((outid = shmget(k4, sizeof(int), 0666 | IPC_CREAT)) == -1) {
        perror("SHMGET");
        exit(1);
    }


    int *mutex, *data, *in, *out;


    // Attach shared memory segments
    if((mutex = shmat(mutexid, (void *)NULL, 0)) == (void *)-1) {
        perror("SHMAT");
        exit(1);
    }
    if((in = shmat(inid, (void *)NULL, 0)) == (void *)-1) {
        perror("SHMAT");
        exit(1);
    }
    if((out = shmat(outid, (void *)NULL, 0)) == (void *)-1) {
        perror("SHMAT");
        exit(1);
    }
    *in =0;
    *out=0;
    *mutex=0;




    int c;
    do {
        printf("\nWhich one do you want...\n1. Producer\n2. Consumer\n3. Exit\nEnter your choice: ");
        scanf("%d", &c);
        if (c == 1) {
            system("gnome-terminal -- ./pro");
        } else if (c == 2) {
            system("gnome-terminal -- ./con");
        } else if (c != 3) {
            printf("\nInvalid choice\n");
        }
    } while (c != 3);
    return 0;
}






producer.c


#include<stdio.h>
#include<stdlib.h>
#include<sys/shm.h>
#include<sys/types.h>
#include<sys/ipc.h>


#define BUFFER_SIZE 5


int main(){
    key_t k1, k2, k3, k4;
    k1 = 9999;
    k2 = 9998;
    k3 = 9997; 
    k4 = 9996; 


    int mutexid, dataid, inid, outid;
    if((mutexid = shmget(k1, sizeof(int), 0666 | IPC_CREAT)) == -1) {
        perror("SHMGET");
        exit(1);
    }
    if((dataid = shmget(k2, BUFFER_SIZE * sizeof(int), 0666 | IPC_CREAT)) == -1) {
        perror("SHMGET");
        exit(1);
    }
    if((inid = shmget(k3, sizeof(int), 0666 | IPC_CREAT)) == -1) {
        perror("SHMGET");
        exit(1);
    }
    if((outid = shmget(k4, sizeof(int), 0666 | IPC_CREAT)) == -1) {
        perror("SHMGET");
        exit(1);
    }


    int *mutex, *data, *in, *out;


    // Attach shared memory segments
    if((mutex = shmat(mutexid, (void *)NULL, 0)) == (void *)-1) {
        perror("SHMAT");
        exit(1);
    }
    if((data = shmat(dataid, (void *)NULL, 0)) == (void *)-1) {
        perror("SHMAT");
        exit(1);
    }
    if((in = shmat(inid, (void *)NULL, 0)) == (void *)-1) {
        perror("SHMAT");
        exit(1);
    }
    if((out = shmat(outid, (void *)NULL, 0)) == (void *)-1) {
        perror("SHMAT");
        exit(1);
    }


    int choice;
    do {
        if ((*in + 1) % BUFFER_SIZE != *out) { 
            if (*mutex == 0) {
                *mutex = 1;
                
                int temp;
                printf("Enter a number to produce: ");
                scanf("%d", &temp);
                data[*in] = temp; 
                printf("buffer[%d] = %d\n", *in, temp);
                *in = (*in + 1) % BUFFER_SIZE; 
                *mutex = 0; 
            } else {
                printf("Other Process is in use! Try again.\n");
            }
        } else {
            printf("Buffer is full! Cannot produce more.\n");
        }


        printf("Do you want to continue producing? (1.Yes 2.No): ");
        scanf("%d", &choice);
    } while (choice != 2);


    return 0;
}




consumer.c




#include<stdio.h>
#include<stdlib.h>
#include<sys/shm.h>
#include<sys/types.h>
#include<sys/ipc.h>


#define BUFFER_SIZE 5


int main() {
    key_t k1, k2, k3, k4;
    k1 = 9999;
    k2 = 9998;
    k3 = 9997;
    k4 = 9996;


    int mutexid, dataid, inid, outid;


    // Shared memory allocation
    if((mutexid = shmget(k1, sizeof(int), 0666 | IPC_CREAT)) == -1) {
        perror("SHMGET");
        exit(1);
    }
    if((dataid = shmget(k2, BUFFER_SIZE * sizeof(int), 0666 | IPC_CREAT)) == -1) {
        perror("SHMGET");
        exit(1);
    }
    if((inid = shmget(k3, sizeof(int), 0666 | IPC_CREAT)) == -1) {
        perror("SHMGET");
        exit(1);
    }
    if((outid = shmget(k4, sizeof(int), 0666 | IPC_CREAT)) == -1) {
        perror("SHMGET");
        exit(1);
    }


    int *mutex, *data, *in, *out;


    // Attach shared memory segments
    if((mutex = shmat(mutexid, (void *)NULL, 0)) == (void *)-1) {
        perror("SHMAT");
        exit(1);
    }
    if((data = shmat(dataid, (void *)NULL, 0)) == (void *)-1) {
        perror("SHMAT");
        exit(1);
    }
    if((in = shmat(inid, (void *)NULL, 0)) == (void *)-1) {
        perror("SHMAT");
        exit(1);
    }
    if((out = shmat(outid, (void *)NULL, 0)) == (void *)-1) {
        perror("SHMAT");
        exit(1);
    }


    int choice;
    do {
        if (*in != *out) {
            if (*mutex == 0) {
                *mutex = 1;  
                printf("Buffer before consuming:\n");
                int i = *out;
                while (i != *in) {
                    printf("buffer[%d] = %d\n", i, data[i]);
                    i = (i + 1) % BUFFER_SIZE;
                }


                printf("\nConsuming: buffer[%d] = %d\n", *out, data[*out]);
                *out = (*out + 1) % BUFFER_SIZE;  
                printf("\nBuffer after consuming:\n");
                i = *out;
                if (*in == *out) {
                    printf("Buffer is empty!\n");
                } else {
                    while (i != *in) {
                        printf("buffer[%d] = %d\n", i, data[i]);
                        i = (i + 1) % BUFFER_SIZE;
                    }
                }


                 
                *mutex = 0; 
            } else {
                printf("Other process is in use! Try again.\n");
            }
        } else {
            printf("Buffer is empty! Cannot consume.\n");
        }


        printf("\nDo you want to continue consuming? (1.Yes 2.No): ");
        scanf("%d", &choice);
    } while (choice != 2);


    return 0;
}










reader-writer




#include<stdio.h>
#include<stdlib.h>
#include<sys/ipc.h>
#include<sys/shm.h>
#include<string.h>
#include<unistd.h>
#define SHMSZ 1024
int main()
{
key_t key1 , key2;
int shmid;
int sec_id;
char *shm , *k , *s;//Data
char *ssm, *j , *t;
key2 = 3400; //Pattern
key1 = 3415;//Data
if((shmid = shmget(key1, SHMSZ, IPC_CREAT | 0666))<0)
{
perror("shmget");
exit(1);
}


if((shm = shmat(shmid,NULL,0)) == (char *)-1)
{
perror("shmat");
exit(1);
}
//***************************************************************
if((sec_id = shmget(key2, SHMSZ, IPC_CREAT | 0666))<0)
{
perror("shmget");
exit(1);
}
if((ssm = shmat(sec_id,NULL,0)) == (char *)-1)
{
perror("shmat");
exit(1);
}
t = ssm;
char pattern[10];
printf("\nEnter the pattern: ");
fgets(pattern,10, stdin); //Will accept till ENTER key is hit...
int len = sizeof(pattern);
for(int i = 0; i < len; i++)
{
*t = pattern[i];
*t++;
}
for (k = ssm; *k != '\0'; k++)
printf("%c",*k);
putchar('\n');


//Reader Priority
int choice;
printf("1. READER PRIORITY \n 2. WRITER PRIORITY\n");
printf("\nEnter the priority (1/2): ");
scanf("%d",&choice);
if(choice == 1)
{
char first = *ssm;
printf("\nThe first character is: %c",first);
if(first == 'R')
{
int rcount = 0;
int wcount = 0;
for (k = ssm; *k != '\0'; k++)
{
if(*k == 'R')
rcount = rcount + 1;
else if(*k == 'W')
wcount = wcount + 1;


}
printf("\nThe no. of readers is: %d",rcount);
printf("\nThe no. of writer is: %d\n",wcount);
for(int i = 0; i < rcount; i++)
{
system("gnome-terminal -- ./r.out");
sleep(2);
}


for(int i = 0; i < wcount; i++)
{
system("gnome-terminal -- ./w.out");
sleep(10);
}
}
else
{
char* h;
h = ssm;
do
{
system("gnome-terminal -- ./w.out");
sleep(10);
h++;
}while(*h != 'R');
int rcount = 0;
int wcount = 0;
for (k = h; *k != '\0'; k++)
{
if(*k == 'R')
rcount = rcount + 1;
else if(*k == 'W')
wcount = wcount + 1;


}
printf("\nThe no. of readers is: %d",rcount);
printf("\nThe no. of writer is: %d\n",wcount);
for(int i = 0; i < rcount; i++)
{
system("gnome-terminal -- ./r.out");


sleep(2);
}
for(int i = 0; i < wcount; i++)
{
system("gnome-terminal -- ./w.out");
sleep(10);
}
}
}
else if(choice == 2)
{
char first = *ssm;
printf("\nThe first character is: %c",first);
if(first == 'W')
{
int rcount = 0;
int wcount = 0;
for (k = ssm; *k != '\0'; k++)
{
if(*k == 'R')
rcount = rcount + 1;
else if(*k == 'W')
wcount = wcount + 1;


}
printf("\nThe no. of readers is: %d",rcount);
printf("\nThe no. of writer is: %d\n",wcount);
for(int i = 0; i < wcount; i++)
{
system("gnome-terminal -- ./w.out");
sleep(10);


}
for(int i = 0; i < rcount; i++)
{
system("gnome-terminal -- ./r.out");
sleep(2);
}
}
else
{
char* h;
h = ssm;
do
{
system("gnome-terminal -- ./r.out");
sleep(2);
h++;
}while(*h != 'W');
int rcount = 0;
int wcount = 0;
for (k = h; *k != '\0'; k++)
{
if(*k == 'R')
rcount = rcount + 1;
else if(*k == 'W')
wcount = wcount + 1;


}
printf("\nThe no. of readers is: %d",rcount);
printf("\nThe no. of writer is: %d\n",wcount);
sleep(3);


for(int i = 0; i < wcount; i++)
{
system("gnome-terminal -- ./w.out");
sleep(10);
}
for(int i = 0; i < rcount; i++)
{
system("gnome-terminal -- ./r.out");
sleep(2);
}
}
}
return 0;
}


Writer with Priority

#include<stdio.h>
#include<stdlib.h>
#include<sys/types.h>
#include<sys/wait.h>
#include<unistd.h>
#include <sys/shm.h>
#include<stdbool.h>
#define SHMSZ 1024
#define MAX_LIMIT 1024
int main()
{
int shmid;


key_t key;
key = 3415;
char *shm , *s , *k;
if ((shmid = shmget(key, SHMSZ, 0666))<0)
{
perror("shmget");
exit(1);
}
if ((shm = shmat(shmid, NULL, 0)) == (char *) -1)
{
perror("shmat");
exit(1);
}
s = shm;
printf("\n%d is the only Write process that is accessing the Shared
Memory...",getpid());
bool temp = true;
while(true)
{
//printf("\nInside the While Loop!!!\n");
if(*s != '\0')
++s;
else if(*s == '\0')
break;


}
char x = *s;


printf("\nThe Data here should be null: %c",x);
char str[MAX_LIMIT];
int choice;
do
{
printf("\nEnter the String to be entered into the Shared Memory: ");
fgets(str, MAX_LIMIT, stdin); //Will accept till ENTER key is hit...
printf("\nAre you sure the string you want to enter is: %s ",str);
printf("\nIf YES -> 1 | NO -> 0: ");
scanf("%d",&choice);
}while(choice != 1);
printf("The String that will be entered into the SHM is: %s\n", str);
for(int i = 0 ; i < sizeof(str) ; i++)
{
*s++ = str[i]; //After the last mem. location, s will point to NULL...
}
sleep(5);
printf("\nThe Write process for %d Process is complete!!!\n",getpid());
for (k = s; *k != '\0'; k++)
{
printf("%c",*k);
}
putchar('\n');
return 0;
}


Reader with Priority

#include<stdio.h>
#include<stdlib.h>
#include<sys/types.h>
#include<sys/wait.h>
#include<unistd.h>
#include <sys/shm.h>
#define SHMSZ 1024
#define MAX_LIMIT 1024
int main()
{
int shmid;
key_t key;
key = 3415;
char *shm , *s , *k;
if ((shmid = shmget(key, SHMSZ, 0666))<0)
{
perror("shmget");
exit(1);
}
if ((shm = shmat(shmid, NULL, 0)) == (char *) -1)
{
perror("shmat");
exit(1);
}
char flag = *shm;
s = shm;
printf("\nThe data at the first location of the Shared Memory is: %c\n",flag);


for (k = shm; *k != '\0'; k++){
printf("%c",*k);
}
sleep(5);
printf("\nThe Read process of the Reader is complete!!!\n");
return 0;
}


_____________________________________________________________________________________________________


Bankers Algorithm




#include<stdio.h>
int main(){
    int n,m,i,j,k,y,ind=0;
    printf("Enter  no. of processes and no. of resources:");
    scanf("%d %d",&n,&m);
    int avail[n],f[n],ans[n],alloc[n][m],maxreq[n][m],need[n][m];
    for(i=0;i<m;i++){
        printf("Enter no. of instances of r%d",i+1);
        scanf("%d",&avail[i]);
    }
    for(i=0;i<n;i++){
        for(j=0;j<m;j++){
            printf("Enter no. of instances of r%d allocated to p%d",j+1,i+1);
            scanf("%d",&alloc[i][j]);
            avail[j]-=alloc[i][j];
        }
    }
    for(i=0;i<n;i++){
        for(j=0;j<m;j++){
            printf("Enter max no. of instances of r%d requested by p%d",j+1,i+1);
            scanf("%d",&maxreq[i][j]);
            need[i][j]=maxreq[i][j]-alloc[i][j];
        }
    }
    for(i=0;i<n;i++){
        f[i]=0;
    }
    for(k=0;k<n;k++){
        for(i=0;i<n;i++){
            if (f[i]==0){
                int flag=0;
                for(j=0;j<m;j++){
                    if(need[i][j]>avail[j]){
                        flag=1;
                        break;
                    }
                }
                if(flag==0){
                    ans[ind++]=i;
                    printf("%d\n",i+1);
                    for(j=0;j<m;j++){
                        avail[j]+=alloc[i][j];
                    }
                    f[i]=1;
                    
                }
                
            }
        }
    }
    int flag=0;
    for(i=0;i<n;i++){
        if(f[i]==0){
            flag=1;
            break;
        }
    }
    if(flag==1){
        printf("Deadlock imminent");
    }
    else{
        printf("SAFE SEQUENCE\n");
        for(i=0;i<n-1;i++){
            printf("P->%d",ans[i]+1);
        }
        printf("P->%d",ans[n-1]+1);
    }
}

_______________________________________________________________________________________________________________________

//Deadlock Detection

#include<stdio.h>
int main(){
    int i,j,np,nr,ind=0;
    printf("Enter no. of processes:");
   	scanf("%d",&np);
    printf("Enter no. of resources:");
   	scanf("%d",&nr);
    int alloc[np][nr],request[np][nr],avail[nr],f[np],ans[np];
    for(i=0;i<np;i++){
        f[i]=0;
    }
    for(i=0;i<nr;i++){
        printf("Enter no. of instances of R%d: ",i+1);
        scanf("%d",&avail[i]);
    }
    for(i=0;i<np;i++){
        for(j=0;j<nr;j++){
            printf("Enter no. of instances of R%d allocated to P%d: ",j+1,i+1);
            scanf("%d",&alloc[i][j]);
            avail[j]-=alloc[i][j];
        }
    }
    for(i=0;i<np;i++){
        for(j=0;j<nr;j++){
            printf("Enter no. of instances of R%d requested by P%d: ",j+1,i+1);
            scanf("%d",&request[i][j]);
        }
    }
    for(int k=0;k<np;k++){
        for(i=0;i<np;i++){
            if(f[i]==0){
			    int flag = 0;
                for(j=0;j<nr;j++){
                    if(request[i][j] > avail[j]){
                        flag = 1;
         			    break;
                    }
                }
                if(flag == 0){
                    ans[ind++] = i+1;
                    for(int y=0;y<nr;y++){
        			    avail[y] += alloc[i][y];
				    }
                    f[i] = 1;
                }
		    }
        }
    }

    int deadlock=0;
    for(i=0;i<np;i++){
  		if(f[i]==0){ 
    		deadlock=1;
     		printf("Deadlock detected\n");
    		break;
  		}
	}
  	if(deadlock==0){
  		printf("Following is the SAFE Sequence\n");
  		for(i=0;i<np-1;i++){
    		printf("P-%d->",ans[i]);
	    }
     	printf("P-%d",ans[np-1]);
    }
}
/*Enter no. of processes:4
Enter no. of resources:3
Enter no. of instances of R1: 2
Enter no. of instances of R2: 3
Enter no. of instances of R3: 2
Enter no. of instances of R1 allocated to P1: 1
Enter no. of instances of R2 allocated to P1: 0
Enter no. of instances of R3 allocated to P1: 1
Enter no. of instances of R1 allocated to P2: 1
Enter no. of instances of R2 allocated to P2: 1
Enter no. of instances of R3 allocated to P2: 0
Enter no. of instances of R1 allocated to P3: 0
Enter no. of instances of R2 allocated to P3: 1
Enter no. of instances of R3 allocated to P3: 0
Enter no. of instances of R1 allocated to P4: 0
Enter no. of instances of R2 allocated to P4: 1
Enter no. of instances of R3 allocated to P4: 0
Enter no. of instances of R1 requested by P1: 0
Enter no. of instances of R2 requested by P1: 0
Enter no. of instances of R3 requested by P1: 1
Enter no. of instances of R1 requested by P2: 1
Enter no. of instances of R2 requested by P2: 0
Enter no. of instances of R3 requested by P2: 0
Enter no. of instances of R1 requested by P3: 0
Enter no. of instances of R2 requested by P3: 0
Enter no. of instances of R3 requested by P3: 1
Enter no. of instances of R1 requested by P4: 0
Enter no. of instances of R2 requested by P4: 2
Enter no. of instances of R3 requested by P4: 0
Following is the SAFE Sequence
P-1->P-2->P-3->P-4*/


______________________________________________________________________________________________________________________________


dining




#include <stdio.h> 
#include <unistd.h> 
#include <semaphore.h> 
#include <stdlib.h> 
#include <pthread.h> 
#define N 5 
#define LEFT (i + N - 1) % N 
#define RIGHT (i + 1) % N 
#define THINKING 0 
#define HUNGRY 1 
#define EATING 2 
int state[N]; 
sem_t mutex; 
sem_t s[N]; 
void test(int i) { 
if (state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] != EATING) { 
state[i] = EATING; 
sem_post(&s[i]); 
} 
} 
void take(int i) { 
sem_wait(&mutex); 
state[i] = HUNGRY; 
printf("\nPhilosopher %d is hungry", i); 
test(i); 
sem_post(&mutex); 
sem_wait(&s[i]); 
} 
void put(int i) { 
sem_wait(&mutex); 
state[i] = THINKING; 
printf("\nPhilosopher %d is putting down forks", i); 
test(LEFT); 
test(RIGHT); 
sem_post(&mutex); 
} 
void* phil(void* i) { 
int* p = (int*)i; 
while (1) { 
printf("\nPhilosopher %d is thinking", *p); 
sleep(2); 
take(*p); 
printf("\nPhilosopher %d is eating", *p); 
sleep(2); 
put(*p); 
} 
} 
int main() { 
pthread_t philosophers[N]; 
sem_init(&mutex, 0, 1); 
int p[N]; 
for (int i = 0; i < N; i++) { 
p[i] = i; 
state[i] = THINKING; // Initialize state 
sem_init(&s[i], 0, 0); // Initialize semaphores 
} 
// Create philosopher threads 
for (int i = 0; i < N; i++) { 
pthread_create(&philosophers[i], NULL, phil, (void*)&p[i]); 
} 
// Wait for all philosopher threads (though they run indefinitely) 
for (int i = 0; i < N; i++) { 
pthread_join(philosophers[i], NULL); 
    } 
 
    return 0; 
}


//paging replacement techniques

#include<stdio.h>
int n,nf;
int in[100];
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;

void getData()
{
    printf("\nEnter length of page reference sequence:");
    scanf("%d",&n);
    printf("\nEnter the page reference sequence:");
    for(i=0; i<n; i++)
        scanf("%d",&in[i]);
    printf("\nEnter no of frames:");
    scanf("%d",&nf);
}

void initialize()
{
    pgfaultcnt=0;
    for(i=0; i<nf; i++)
        p[i]=9999;
}

int isHit(int data)
{
    hit=0;
    for(j=0; j<nf; j++)
    {
        if(p[j]==data)
        {
            hit=1;
            break;
        }

    }

    return hit;
}

int getHitIndex(int data)
{
    int hitind;
    for(k=0; k<nf; k++)
    {
        if(p[k]==data)
        {
            hitind=k;
            break;
        }
    }
    return hitind;
}

void dispPages()
{
    for (k=0; k<nf; k++)
    {
        if(p[k]!=9999)
            printf(" %d",p[k]);
    }

}

void dispPgFaultCnt()
{
    printf("\nTotal no of page faults:%d",pgfaultcnt);
}

void fifo()
{
    initialize();
    for(i=0; i<n; i++)
    {
        printf("\nFor %d :",in[i]);

        if(isHit(in[i])==0)
        {

            for(k=0; k<nf-1; k++)
                p[k]=p[k+1];

            p[k]=in[i];
            pgfaultcnt++;
            dispPages();
        }
        else
            printf("No page fault");
    }
    dispPgFaultCnt();
}


void optimal()
{
    initialize();
    int near[50];
    for(i=0; i<n; i++)
    {

        printf("\nFor %d :",in[i]);

        if(isHit(in[i])==0)
        {

            for(j=0; j<nf; j++)
            {
                int pg=p[j];
                int found=0;
                for(k=i; k<n; k++)
                {
                    if(pg==in[k])
                    {
                        near[j]=k;
                        found=1;
                        break;
                    }
                    else
                        found=0;
                }
                if(!found)
                    near[j]=9999;
            }
            int max=-9999;
            int repindex;
            for(j=0; j<nf; j++)
            {
                if(near[j]>max)
                {
                    max=near[j];
                    repindex=j;
                }
            }
            p[repindex]=in[i];
            pgfaultcnt++;

            dispPages();
        }
        else
            printf("No page fault");
    }
    dispPgFaultCnt();
}

void lru()
{
    initialize();

    int least[50];
    for(i=0; i<n; i++)
    {

        printf("\nFor %d :",in[i]);

        if(isHit(in[i])==0)
        {

            for(j=0; j<nf; j++)
            {
                int pg=p[j];
                int found=0;
                for(k=i-1; k>=0; k--)
                {
                    if(pg==in[k])
                    {
                        least[j]=k;
                        found=1;
                        break;
                    }
                    else
                        found=0;
                }
                if(!found)
                    least[j]=-9999;
            }
            int min=9999;
            int repindex;
            for(j=0; j<nf; j++)
            {
                if(least[j]<min)
                {
                    min=least[j];
                    repindex=j;
                }
            }
            p[repindex]=in[i];
            pgfaultcnt++;

            dispPages();
        }
        else
            printf("No page fault!");
    }
    dispPgFaultCnt();
}

void lfu()
{
    int usedcnt[100];
    int least,repin,sofarcnt=0,bn;
    initialize();
    for(i=0; i<nf; i++)
        usedcnt[i]=0;

    for(i=0; i<n; i++)
    {

        printf("\n For %d :",in[i]);
        if(isHit(in[i]))
        {
            int hitind=getHitIndex(in[i]);
            usedcnt[hitind]++;
            printf("No page fault!");
        }
        else
        {
            pgfaultcnt++;
            if(bn<nf)
            {
                p[bn]=in[i];
                usedcnt[bn]=usedcnt[bn]+1;
                bn++;
            }
            else
            {
                least=9999;
                for(k=0; k<nf; k++)
                    if(usedcnt[k]<least)
                    {
                        least=usedcnt[k];
                        repin=k;
                    }
                p[repin]=in[i];
                sofarcnt=0;
                for(k=0; k<=i; k++)
                    if(in[i]==in[k])
                        sofarcnt=sofarcnt+1;
                usedcnt[repin]=sofarcnt;
            }

            dispPages();
        }

    }
    dispPgFaultCnt();
}

void secondchance()
{
    int usedbit[50];
    int victimptr=0;
    initialize();
    for(i=0; i<nf; i++)
        usedbit[i]=0;
    for(i=0; i<n; i++)
    {
        printf("\nFor %d:",in[i]);
        if(isHit(in[i]))
        {
            printf("No page fault!");
            int hitindex=getHitIndex(in[i]);
            if(usedbit[hitindex]==0)
                usedbit[hitindex]=1;
        }
        else
        {
            pgfaultcnt++;
            if(usedbit[victimptr]==1)
            {
                do
                {
                    usedbit[victimptr]=0;
                    victimptr++;
                    if(victimptr==nf)
                        victimptr=0;
                }
                while(usedbit[victimptr]!=0);
            }
            if(usedbit[victimptr]==0)
            {
                p[victimptr]=in[i];
                usedbit[victimptr]=1;
                victimptr++;
            }
            dispPages();

        }
        if(victimptr==nf)
            victimptr=0;
    }
    dispPgFaultCnt();
}

int main()
{
    int choice;
    while(1)
    {
        printf("\nPage Replacement Algorithms\n1.Enter data\n2.FIFO\n3.Optimal\n4.LRU\n5.LFU\n6.Second Chance\n7.Exit\nEnter your choice:");
        scanf("%d",&choice);
        switch(choice)
        {
        case 1:
            getData();
            break;
        case 2:
            fifo();
            break;
        case 3:
            optimal();
            break;
        case 4:
            lru();
            break;
        case 5:
            lfu();
            break;
        case 6:
            secondchance();
            break;
        default:
            return 0;
            break;
        }
    }
}


____________________________________________________________



//paging adress translation

#include<stdio.h>

int main()
{
 int ms, ps, nop, np, rempages, i, j, x, y, pa, offset;
 int s[10], fno[10][20];



printf("\nEnter the memory size -- ");
scanf("%d",&ms);

printf("\nEnter the page size -- ");
scanf("%d",&ps);

nop = ms/ps;
printf("\nThe no. of pages available in memory are -- %d ",nop);

printf("\nEnter number of processes -- ");
 scanf("%d",&np);
rempages = nop;
for(i=1;i<=np;i++)

{

printf("\nEnter no. of pages required for p[%d]-- ",i);
 scanf("%d",&s[i]);

if(s[i] >rempages)
{

printf("\nMemory is Full");
break;
}
rempages = rempages - s[i];

printf("\nEnter pagetable for p[%d] --- ",i);
 for(j=0;j<s[i];j++)
scanf("%d",&fno[i][j]);
}

printf("\nEnter Logical Address to find Physical Address ");
printf("\nEnter process no. and pagenumber and offset -- ");

scanf("%d %d %d",&x,&y, &offset);



if(x>np || y>=s[i] || offset>=ps)
printf("\nInvalid Process or Page Number or offset");

else
{ pa=fno[x][y]*ps+offset;
printf("\nThe Physical Address is -- %d",pa);

}
return 0;
}



_______________________________________________________________________________________________________________________________________________________________________________________________________________
//****//

Disk Scheduling

#include <stdio.h>
#include <stdlib.h>

#define MAX 100

void fcfs(int requests[], int n, int head) {
    int seek_time = 0;
    printf("\nFCFS Disk Scheduling Algorithm:\n");
    printf("Seek Sequence: ");
    for (int i = 0; i < n; i++) {
        printf("%d -> ", requests[i]);
        seek_time += abs(requests[i] - head);
        head = requests[i];
    }
    printf("\nTotal Seek Time: %d\n", seek_time);
}

void sstf(int requests[], int n, int head) {
    int seek_time = 0, completed[MAX] = {0};
    printf("\nSSTF Disk Scheduling Algorithm:\n");
    printf("Seek Sequence: ");
    
    for (int i = 0; i < n; i++) {
        int min_distance = 1e9, index = -1;
        for (int j = 0; j < n; j++) {
            if (!completed[j] && abs(requests[j] - head) < min_distance) {
                min_distance = abs(requests[j] - head);
                index = j;
            }
        }
        printf("%d -> ", requests[index]);
        seek_time += abs(requests[index] - head);
        head = requests[index];
        completed[index] = 1;
    }
    printf("\nTotal Seek Time: %d\n", seek_time);
}

void scan(int requests[], int n, int head, int disk_size) {
    int seek_time = 0, i, j, sorted[MAX];
    
    // Sorting requests
    for (i = 0; i < n; i++) {
        sorted[i] = requests[i];
    }
    sorted[n] = disk_size;  // Adding disk_size for boundary
    n++;
    for (i = 0; i < n-1; i++) {
        for (j = i+1; j < n; j++) {
            if (sorted[i] > sorted[j]) {
                int temp = sorted[i];
                sorted[i] = sorted[j];
                sorted[j] = temp;
            }
        }
    }

    printf("\nSCAN Disk Scheduling Algorithm:\n");
    printf("Seek Sequence: ");
    
    // Moving left
    for (i = 0; i < n; i++) {
        if (sorted[i] >= head) break;
    }
    
    // Moving right after crossing head
    for (j = i; j < n; j++) {
        printf("%d -> ", sorted[j]);
        seek_time += abs(sorted[j] - head);
        head = sorted[j];
    }
    // Then to the left (returning to 0)
    for (j = i-1; j >= 0; j--) {
        printf("%d -> ", sorted[j]);
        seek_time += abs(sorted[j] - head);
        head = sorted[j];
    }
    printf("\nTotal Seek Time: %d\n", seek_time);
}

void clook(int requests[], int n, int head) {
    int seek_time = 0, i, j, sorted[MAX];
    
    // Sorting requests
    for (i = 0; i < n; i++) {
        sorted[i] = requests[i];
    }
    for (i = 0; i < n-1; i++) {
        for (j = i+1; j < n; j++) {
            if (sorted[i] > sorted[j]) {
                int temp = sorted[i];
                sorted[i] = sorted[j];
                sorted[j] = temp;
            }
        }
    }

    printf("\nC-LOOK Disk Scheduling Algorithm:\n");
    printf("Seek Sequence: ");
    
    // Moving right from the head
    for (i = 0; i < n; i++) {
        if (sorted[i] >= head) break;
    }
    
    // Moving to the right first
    for (j = i; j < n; j++) {
        printf("%d -> ", sorted[j]);
        seek_time += abs(sorted[j] - head);
        head = sorted[j];
    }
    // Then wrap around to the leftmost
    for (j = 0; j < i; j++) {
        printf("%d -> ", sorted[j]);
        seek_time += abs(sorted[j] - head);
        head = sorted[j];
    }
    printf("\nTotal Seek Time: %d\n", seek_time);
}

int main() {
    int n, head, disk_size;
    int requests[MAX];
    
    printf("Enter the number of requests: ");
    scanf("%d", &n);
    
    printf("Enter the disk requests: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &requests[i]);
    }

    printf("Enter the initial head position: ");
    scanf("%d", &head);
    
    printf("Enter the disk size: ");
    scanf("%d", &disk_size);
    
    fcfs(requests, n, head);
    sstf(requests, n, head);
    scan(requests, n, head, disk_size);
    clook(requests, n, head);
    
    return 0;
}

/*Enter the number of requests: 10
Enter the disk requests: 176 89 54 32 67 48 82 11 20 59
Enter the initial head position: 50
Enter the disk size: 200

FCFS Disk Scheduling Algorithm:
Seek Sequence: 176 -> 89 -> 54 -> 32 -> 67 -> 48 -> 82 -> 11 -> 20 -> 59 ->
Total Seek Time: 477

SSTF Disk Scheduling Algorithm:
Seek Sequence: 48 -> 54 -> 59 -> 67 -> 82 -> 89 -> 32 -> 20 -> 11 -> 176 ->
Total Seek Time: 286

SCAN Disk Scheduling Algorithm:
Seek Sequence: 54 -> 59 -> 67 -> 82 -> 89 -> 176 -> 200 -> 48 -> 32 -> 20 -> 11 ->
Total Seek Time: 339

C-LOOK Disk Scheduling Algorithm:
Seek Sequence: 54 -> 59 -> 67 -> 82 -> 89 -> 176 -> 11 -> 20 -> 32 -> 48 ->
Total Seek Time: 328

[Program finished]*/
